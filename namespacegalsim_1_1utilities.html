<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GalSim: galsim.utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim.utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_attribute_dict.html">AttributeDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary class that allows for easy initialization and refs to key values via attributes.  <a href="classgalsim_1_1utilities_1_1_attribute_dict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1doc__inherit.html">doc_inherit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Docstring inheriting method descriptor The class itself is also used as a decorator.  <a href="classgalsim_1_1utilities_1_1doc__inherit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1lazy__property.html">lazy_property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">meant to be used for lazy evaluation of an object attribute.  <a href="classgalsim_1_1utilities_1_1lazy__property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_l_r_u___cache.html">LRU_Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified Least Recently Used Cache.  <a href="classgalsim_1_1utilities_1_1_l_r_u___cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_ordered_weak_ref.html">OrderedWeakRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_simple_generator.html">SimpleGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that is constructed with an arbitrary object.  <a href="classgalsim_1_1utilities_1_1_simple_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_weak_method.html">WeakMethod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abce8280a02c70e4267318a1e44416fd2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#abce8280a02c70e4267318a1e44416fd2">roll2d</a> (image, shape)</td></tr>
<tr class="memdesc:abce8280a02c70e4267318a1e44416fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently.  <a href="#abce8280a02c70e4267318a1e44416fd2">More...</a><br /></td></tr>
<tr class="separator:abce8280a02c70e4267318a1e44416fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa903eb2a1996461798e389862df86309"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aa903eb2a1996461798e389862df86309">kxky</a> (array_shape=(256, 256))</td></tr>
<tr class="memdesc:aa903eb2a1996461798e389862df86309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape.  <a href="#aa903eb2a1996461798e389862df86309">More...</a><br /></td></tr>
<tr class="separator:aa903eb2a1996461798e389862df86309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fb8d5b55f14f6fde5f3d3df0f73114"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ad2fb8d5b55f14f6fde5f3d3df0f73114">g1g2_to_e1e2</a> (g1, g2)</td></tr>
<tr class="memdesc:ad2fb8d5b55f14f6fde5f3d3df0f73114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>.  <a href="#ad2fb8d5b55f14f6fde5f3d3df0f73114">More...</a><br /></td></tr>
<tr class="separator:ad2fb8d5b55f14f6fde5f3d3df0f73114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcb65492635b09b9dff27d7a12ad92a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a0fcb65492635b09b9dff27d7a12ad92a">rotate_xy</a> (x, y, theta)</td></tr>
<tr class="memdesc:a0fcb65492635b09b9dff27d7a12ad92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system.  <a href="#a0fcb65492635b09b9dff27d7a12ad92a">More...</a><br /></td></tr>
<tr class="separator:a0fcb65492635b09b9dff27d7a12ad92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5fa9c179421d0064d1e8e939411f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a9ed5fa9c179421d0064d1e8e939411f9">parse_pos_args</a> (args, kwargs, name1, name2, integer=False, others=[])</td></tr>
<tr class="memdesc:a9ed5fa9c179421d0064d1e8e939411f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the args and kwargs of a function call to be some kind of position.  <a href="#a9ed5fa9c179421d0064d1e8e939411f9">More...</a><br /></td></tr>
<tr class="separator:a9ed5fa9c179421d0064d1e8e939411f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68591956c528f7aa1e3ccba3b4ecbaf9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a68591956c528f7aa1e3ccba3b4ecbaf9">__init__</a> (self)</td></tr>
<tr class="separator:a68591956c528f7aa1e3ccba3b4ecbaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c991442b03f839b02101d9b40d0ee27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a6c991442b03f839b02101d9b40d0ee27">__getattr__</a> (self, name)</td></tr>
<tr class="separator:a6c991442b03f839b02101d9b40d0ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb58a1bc2d102a1d8c5879ded059e7de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#adb58a1bc2d102a1d8c5879ded059e7de">__setattr__</a> (self, name, value)</td></tr>
<tr class="separator:adb58a1bc2d102a1d8c5879ded059e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0a3eb3fcb0585b5dfc2f6d200d3422"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#adb0a3eb3fcb0585b5dfc2f6d200d3422">merge</a> (self, other)</td></tr>
<tr class="separator:adb0a3eb3fcb0585b5dfc2f6d200d3422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54238ac7428cd16bc2b30286fd045f50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a54238ac7428cd16bc2b30286fd045f50">__bool__</a> (self)</td></tr>
<tr class="separator:a54238ac7428cd16bc2b30286fd045f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd100eee3224f5675629ac62bfc8a4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a4acd100eee3224f5675629ac62bfc8a4">__repr__</a> (self)</td></tr>
<tr class="separator:a4acd100eee3224f5675629ac62bfc8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3f1e92958a2ee5b02a3b70ee1a259"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#afff3f1e92958a2ee5b02a3b70ee1a259">__len__</a> (self)</td></tr>
<tr class="separator:afff3f1e92958a2ee5b02a3b70ee1a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0357fc12802dc70e7749aaf3867fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ab5a0357fc12802dc70e7749aaf3867fc">rand_arr</a> (shape, deviate)</td></tr>
<tr class="memdesc:ab5a0357fc12802dc70e7749aaf3867fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 2d array of random deviates (of any sort).  <a href="#ab5a0357fc12802dc70e7749aaf3867fc">More...</a><br /></td></tr>
<tr class="separator:ab5a0357fc12802dc70e7749aaf3867fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719a9cb9817817b708d81d4801fdda4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a719a9cb9817817b708d81d4801fdda4d">convert_interpolant</a> (interpolant)</td></tr>
<tr class="memdesc:a719a9cb9817817b708d81d4801fdda4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string.  <a href="#a719a9cb9817817b708d81d4801fdda4d">More...</a><br /></td></tr>
<tr class="separator:a719a9cb9817817b708d81d4801fdda4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407a3fbc4fbd9d4a03caa8fe29b531f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a407a3fbc4fbd9d4a03caa8fe29b531f1">thin_tabulated_values</a> (x, f, rel_err=1.e-4, trim_zeros=True, preserve_range=True, fast_search=True)</td></tr>
<tr class="memdesc:a407a3fbc4fbd9d4a03caa8fe29b531f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a407a3fbc4fbd9d4a03caa8fe29b531f1">More...</a><br /></td></tr>
<tr class="separator:a407a3fbc4fbd9d4a03caa8fe29b531f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ade429d89b7f6db0b705638978a1f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a18ade429d89b7f6db0b705638978a1f8">old_thin_tabulated_values</a> (x, f, rel_err=1.e-4, preserve_range=False)</td></tr>
<tr class="memdesc:a18ade429d89b7f6db0b705638978a1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a18ade429d89b7f6db0b705638978a1f8">More...</a><br /></td></tr>
<tr class="separator:a18ade429d89b7f6db0b705638978a1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a6476f572c4c61b14b5b889ea56c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#afa8a6476f572c4c61b14b5b889ea56c7">horner</a> (x, coef, dtype=None)</td></tr>
<tr class="memdesc:afa8a6476f572c4c61b14b5b889ea56c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate univariate polynomial using Horner's method.  <a href="#afa8a6476f572c4c61b14b5b889ea56c7">More...</a><br /></td></tr>
<tr class="separator:afa8a6476f572c4c61b14b5b889ea56c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47733db76293916f0ec76ab2ea965230"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a47733db76293916f0ec76ab2ea965230">horner2d</a> (x, y, coefs, dtype=None)</td></tr>
<tr class="memdesc:a47733db76293916f0ec76ab2ea965230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate bivariate polynomial using nested Horner's method.  <a href="#a47733db76293916f0ec76ab2ea965230">More...</a><br /></td></tr>
<tr class="separator:a47733db76293916f0ec76ab2ea965230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75983adc25af9d711ddab3d480bb2eec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a75983adc25af9d711ddab3d480bb2eec">deInterleaveImage</a> (image, N, conserve_flux=False, suppress_warnings=False)</td></tr>
<tr class="memdesc:a75983adc25af9d711ddab3d480bb2eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The routine to do the opposite of what 'interleaveImages' routine does.  <a href="#a75983adc25af9d711ddab3d480bb2eec">More...</a><br /></td></tr>
<tr class="separator:a75983adc25af9d711ddab3d480bb2eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eaa61b14743f05cbfa4b90c9f23817"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ac1eaa61b14743f05cbfa4b90c9f23817">interleaveImages</a> (im_list, N, offsets, add_flux=True, suppress_warnings=False, catch_offset_errors=True)</td></tr>
<tr class="memdesc:ac1eaa61b14743f05cbfa4b90c9f23817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the pixel values from two or more images and into a single larger image.  <a href="#ac1eaa61b14743f05cbfa4b90c9f23817">More...</a><br /></td></tr>
<tr class="separator:ac1eaa61b14743f05cbfa4b90c9f23817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913170afc5617be17478cac3ddd68ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a8913170afc5617be17478cac3ddd68ef">printoptions</a> (args, kwargs)</td></tr>
<tr class="separator:a8913170afc5617be17478cac3ddd68ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502072778652153adf7b62d061f83c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a5502072778652153adf7b62d061f83c7">listify</a> (arg)</td></tr>
<tr class="memdesc:a5502072778652153adf7b62d061f83c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn argument into a list if not already iterable.  <a href="#a5502072778652153adf7b62d061f83c7">More...</a><br /></td></tr>
<tr class="separator:a5502072778652153adf7b62d061f83c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8816b0793b175a6a8dce76c483cfb490"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a8816b0793b175a6a8dce76c483cfb490">dol_to_lod</a> (dol, N=None)</td></tr>
<tr class="memdesc:a8816b0793b175a6a8dce76c483cfb490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate list of dicts from dict of lists (with broadcasting).  <a href="#a8816b0793b175a6a8dce76c483cfb490">More...</a><br /></td></tr>
<tr class="separator:a8816b0793b175a6a8dce76c483cfb490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88375098001fff5fe23c210ebe594025"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a88375098001fff5fe23c210ebe594025">structure_function</a> (image)</td></tr>
<tr class="memdesc:a88375098001fff5fe23c210ebe594025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the angularly-averaged structure function of a 2D random field.  <a href="#a88375098001fff5fe23c210ebe594025">More...</a><br /></td></tr>
<tr class="separator:a88375098001fff5fe23c210ebe594025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa008e6534e342704d9883af7f12a8701"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aa008e6534e342704d9883af7f12a8701">combine_wave_list</a> (args)</td></tr>
<tr class="memdesc:aa008e6534e342704d9883af7f12a8701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine wave_list attributes of all objects in obj_list while respecting blue_limit and red_limit attributes.  <a href="#aa008e6534e342704d9883af7f12a8701">More...</a><br /></td></tr>
<tr class="separator:aa008e6534e342704d9883af7f12a8701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756323f12160ef3a40de2e609260e284"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a756323f12160ef3a40de2e609260e284">functionize</a> (f)</td></tr>
<tr class="memdesc:a756323f12160ef3a40de2e609260e284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate a function <code>f</code> which accepts scalar positional or keyword arguments, to accept arguments that can be either scalars or <em>functions</em>.  <a href="#a756323f12160ef3a40de2e609260e284">More...</a><br /></td></tr>
<tr class="separator:a756323f12160ef3a40de2e609260e284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2847aa29baeb6ae446ea195d9a528e80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a2847aa29baeb6ae446ea195d9a528e80">math_eval</a> (str, other_modules=())</td></tr>
<tr class="memdesc:a2847aa29baeb6ae446ea195d9a528e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a string that may include numpy, np, or math commands.  <a href="#a2847aa29baeb6ae446ea195d9a528e80">More...</a><br /></td></tr>
<tr class="separator:a2847aa29baeb6ae446ea195d9a528e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a4c09e268a8714dd5f27e832979d54"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a52a4c09e268a8714dd5f27e832979d54">binomial</a> (a, b, n)</td></tr>
<tr class="memdesc:a52a4c09e268a8714dd5f27e832979d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return xy coefficients of (ax + by)^n ordered by descending powers of a.  <a href="#a52a4c09e268a8714dd5f27e832979d54">More...</a><br /></td></tr>
<tr class="separator:a52a4c09e268a8714dd5f27e832979d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae8f7ef417c486f0a42e095eed1ef1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a8aae8f7ef417c486f0a42e095eed1ef1">unweighted_moments</a> (image, origin=None)</td></tr>
<tr class="memdesc:a8aae8f7ef417c486f0a42e095eed1ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes unweighted 0th, 1st, and 2nd moments in image coordinates.  <a href="#a8aae8f7ef417c486f0a42e095eed1ef1">More...</a><br /></td></tr>
<tr class="separator:a8aae8f7ef417c486f0a42e095eed1ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bbb93028dc0e0b9c202068390efed7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a14bbb93028dc0e0b9c202068390efed7">unweighted_shape</a> (arg)</td></tr>
<tr class="memdesc:a14bbb93028dc0e0b9c202068390efed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes unweighted second moment size and ellipticity given either an image or a dict of unweighted moments.  <a href="#a14bbb93028dc0e0b9c202068390efed7">More...</a><br /></td></tr>
<tr class="separator:a14bbb93028dc0e0b9c202068390efed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a53067a6269fc4a150f25a7d5fc476"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a43a53067a6269fc4a150f25a7d5fc476">rand_with_replacement</a> (n, n_choices, rng, weight=None, _n_rng_calls=False)</td></tr>
<tr class="memdesc:a43a53067a6269fc4a150f25a7d5fc476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select some number of random choices from a list, with replacement, using a supplied RNG.  <a href="#a43a53067a6269fc4a150f25a7d5fc476">More...</a><br /></td></tr>
<tr class="separator:a43a53067a6269fc4a150f25a7d5fc476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c91cc452cf354616c9c870c6e1f775e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a3c91cc452cf354616c9c870c6e1f775e">check_share_file</a> (filename, subdir)</td></tr>
<tr class="memdesc:a3c91cc452cf354616c9c870c6e1f775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find SED or Bandpass file, possibly adding share_dir/subdir.  <a href="#a3c91cc452cf354616c9c870c6e1f775e">More...</a><br /></td></tr>
<tr class="separator:a3c91cc452cf354616c9c870c6e1f775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b0ba2ce1f706475c4ee33d44d9ae89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af3b0ba2ce1f706475c4ee33d44d9ae89">nCr</a> (n, r)</td></tr>
<tr class="memdesc:af3b0ba2ce1f706475c4ee33d44d9ae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combinations.  <a href="#af3b0ba2ce1f706475c4ee33d44d9ae89">More...</a><br /></td></tr>
<tr class="separator:af3b0ba2ce1f706475c4ee33d44d9ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e43dc101926dc4cde4ff9977bb5ef4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a72e43dc101926dc4cde4ff9977bb5ef4">ensure_dir</a> (target)</td></tr>
<tr class="memdesc:a72e43dc101926dc4cde4ff9977bb5ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the directory for the target location exists, watching for a race condition.  <a href="#a72e43dc101926dc4cde4ff9977bb5ef4">More...</a><br /></td></tr>
<tr class="separator:a72e43dc101926dc4cde4ff9977bb5ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a54238ac7428cd16bc2b30286fd045f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54238ac7428cd16bc2b30286fd045f50">&#9670;&nbsp;</a></span>__bool__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__bool__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c991442b03f839b02101d9b40d0ee27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c991442b03f839b02101d9b40d0ee27">&#9670;&nbsp;</a></span>__getattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__getattr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68591956c528f7aa1e3ccba3b4ecbaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68591956c528f7aa1e3ccba3b4ecbaf9">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afff3f1e92958a2ee5b02a3b70ee1a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff3f1e92958a2ee5b02a3b70ee1a259">&#9670;&nbsp;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4acd100eee3224f5675629ac62bfc8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acd100eee3224f5675629ac62bfc8a4">&#9670;&nbsp;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb58a1bc2d102a1d8c5879ded059e7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb58a1bc2d102a1d8c5879ded059e7de">&#9670;&nbsp;</a></span>__setattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.__setattr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52a4c09e268a8714dd5f27e832979d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a4c09e268a8714dd5f27e832979d54">&#9670;&nbsp;</a></span>binomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.binomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return xy coefficients of (ax + by)^n ordered by descending powers of a. </p>
<p>For example:</p>
<h1>(x + y)^3 = 1 x^3 + 3 x^2 y + 3 x y^2 + 1 y^3</h1>
<p>&gt;&gt;&gt; print(binomial(1, 1, 3)) array([ 1., 3., 3., 1.])</p>
<pre class="fragment"># (2 x + y)^3 = 8 x^3 + 12 x^2 y + 6 x y^2 + 1 y^3
&gt;&gt;&gt;  print(binomial(2, 1, 3))
array([ 8.,  12.,  6.,  1.])
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar in binomial to be expanded. </td></tr>
    <tr><td class="paramname">b</td><td>Second scalar in binomial to be expanded. </td></tr>
    <tr><td class="paramname">n</td><td>Exponent of expansion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of coefficients in expansion. </dd></dl>

</div>
</div>
<a id="a3c91cc452cf354616c9c870c6e1f775e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c91cc452cf354616c9c870c6e1f775e">&#9670;&nbsp;</a></span>check_share_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.check_share_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subdir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find SED or Bandpass file, possibly adding share_dir/subdir. </p>

</div>
</div>
<a id="aa008e6534e342704d9883af7f12a8701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa008e6534e342704d9883af7f12a8701">&#9670;&nbsp;</a></span>combine_wave_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.combine_wave_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine wave_list attributes of all objects in obj_list while respecting blue_limit and red_limit attributes. </p>
<p>Should work with SEDs, Bandpasses, and ChromaticObjects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_list</td><td>List of SED, Bandpass, or ChromaticObject objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wave_list, blue_limit, red_limit </dd></dl>

</div>
</div>
<a id="a719a9cb9817817b708d81d4801fdda4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719a9cb9817817b708d81d4801fdda4d">&#9670;&nbsp;</a></span>convert_interpolant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.convert_interpolant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string. </p>

</div>
</div>
<a id="a75983adc25af9d711ddab3d480bb2eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75983adc25af9d711ddab3d480bb2eec">&#9670;&nbsp;</a></span>deInterleaveImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.deInterleaveImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conserve_flux</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suppress_warnings</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The routine to do the opposite of what 'interleaveImages' routine does. </p>
<p>It generates a (uniform) dither sequence of low resolution images from a high resolution image.</p>
<p>Many pixel level detector effects, such as interpixel capacitance, persistence, charge diffusion etc. can be included only on images drawn at the native pixel scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include the effects of detector non-idealities can be obtained by drawing multiple undersampled images (with the detector effects included) that are offset from each other by a fraction of a pixel. If the offsets are uniformly spaced, then images can be combined using 'interleaveImages' into a Nyquist-sampled image.</p>
<p>Drawing multiple low resolution images of a light profile can be a lot slower than drawing a high resolution image of the same profile, even if the total number of pixels is the same. A uniformly offset dither sequence can be extracted from a well-resolved image that is drawn by convolving the surface brightness profile explicitly with the native pixel response and setting a lower sampling scale (or higher sampling rate) using the &lsquo;pixel_scale&rsquo; argument in <a class="el" href="namespacegalsim_1_1gsobject.html#ae6973ff2ec617b3bce96aef8989afc41" title="Draw this profile into an Image by shooting photons. ">drawImage()</a> routine and setting the &lsquo;method&rsquo; parameter to &lsquo;no_pixel&rsquo;.</p>
<p>Here is an example script using this routine:</p>
<h2>Interleaving four Gaussian images </h2>
<pre class="fragment">&gt;&gt;&gt; n = 2
&gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)
&gt;&gt;&gt; gal_pix = galsim.Convolve([gal,galsim.Pixel(scale=1.0)])
&gt;&gt;&gt; img = gal_pix.drawImage(gal_pix,scale=1.0/n,method='no_pixel')
&gt;&gt;&gt; im_list, offsets = galsim.utilities.deInterleaveImage(img,N=n)
&gt;&gt;&gt; for im in im_list:
&gt;&gt;&gt;     im.applyNonlinearity(lambda x: x-0.01*x**2) #detector effects
&gt;&gt;&gt; img_new = galsim.utilities.interleaveImages(im_list,N=n,offsets)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input image from which lower resolution images are extracted. </td></tr>
    <tr><td class="paramname">N</td><td>Number of images extracted in either directions. It can be of type 'int' if equal number of images are extracted in both directions or a list or tuple of two integers, containing the number of images in x and y directions respectively. </td></tr>
    <tr><td class="paramname">conserve_flux</td><td>Should the routine output images that have, on average, same total pixel values as the input image (True) or should the pixel values summed over all the images equal the sum of pixel values of the input image (False)? [default: False] </td></tr>
    <tr><td class="paramname">suppress_warnings</td><td>Suppresses the warnings about the pixel scale of the output, if True. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of images and offsets to reconstruct the input image using 'interleaveImages'. </dd></dl>

</div>
</div>
<a id="a8816b0793b175a6a8dce76c483cfb490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8816b0793b175a6a8dce76c483cfb490">&#9670;&nbsp;</a></span>dol_to_lod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.dol_to_lod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate list of dicts from dict of lists (with broadcasting). </p>
<p>Specifically, generate "scalar-valued" kwargs dictionaries from a kwarg dictionary with values that are length-N lists, or possibly length-1 lists or scalars that should be broadcasted up to length-N lists. </p>

</div>
</div>
<a id="a72e43dc101926dc4cde4ff9977bb5ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e43dc101926dc4cde4ff9977bb5ef4">&#9670;&nbsp;</a></span>ensure_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.ensure_dir </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure the directory for the target location exists, watching for a race condition. </p>
<p>In particular check if the OS reported that the directory already exists when running makedirs, which can happen if another process creates it before this one can </p>

</div>
</div>
<a id="a756323f12160ef3a40de2e609260e284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756323f12160ef3a40de2e609260e284">&#9670;&nbsp;</a></span>functionize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.functionize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate a function <code>f</code> which accepts scalar positional or keyword arguments, to accept arguments that can be either scalars or <em>functions</em>. </p>
<p>If the arguments include univariate (N-variate) functions, then the output will be a univariate (N-variate) function. While it's okay to mix scalar and N-variate function arguments, it is an error to mix N-variate and M-variate function arguments.</p>
<p>As an example:</p>
<p>&gt;&gt;&gt; def f(x, y): # Function of two scalars. ... return x + y &gt;&gt;&gt; decorated = functionize(f) # Function of two scalars, functions, or a mix. &gt;&gt;&gt; result = f(2, 3) # 5 &gt;&gt;&gt; result = f(2, lambda u: u) # Generates a TypeError &gt;&gt;&gt; result = decorated(2, 3) # Scalar args returns a scalar &gt;&gt;&gt; result = decorated(2, lambda u: u) # Univariate argument leads to a univariate output. &gt;&gt;&gt; print(result(5)) # 7 &gt;&gt;&gt; result = decorated(2, lambda u,v: u*v) # Bivariate argument leads to a bivariate output. &gt;&gt;&gt; print(result(5, 7)) # 2 + (5*7) = 37</p>
<p>We can use arguments that accept keyword arguments too:</p>
<p>&gt;&gt;&gt; def f2(u, v=None): ... if v is None: ... v = 6.0 ... return u / v &gt;&gt;&gt; result = decorated(2, f2) &gt;&gt;&gt; print(result(12)) # 2 + (12./6) = 4.0 &gt;&gt;&gt; print(result(12, v=4)) # 2 + (12/4) = 5</p>
<p>Note that you can also use python's decorator syntax:</p>
<p>&gt;&gt;&gt;  &gt;&gt;&gt; def f(x, y): ... return x + y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be decorated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decorated function. </dd></dl>

</div>
</div>
<a id="ad2fb8d5b55f14f6fde5f3d3df0f73114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fb8d5b55f14f6fde5f3d3df0f73114">&#9670;&nbsp;</a></span>g1g2_to_e1e2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.g1g2_to_e1e2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>. </p>
<p>Here <code>g1</code> and <code>g2</code> are reduced shears, and <code>e1</code> and <code>e2</code> are distortions - see <a class="el" href="shear_8py.html" title="Redefinition of the Shear class at the Python layer. ">shear.py</a> for definitions of reduced shear and distortion in terms of axis ratios or other ways of specifying ellipses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First reduced shear component </td></tr>
    <tr><td class="paramname">g2</td><td>Second reduced shear component <pre class="fragment">@returns the corresponding distortions, e1 and e2.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa8a6476f572c4c61b14b5b889ea56c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a6476f572c4c61b14b5b889ea56c7">&#9670;&nbsp;</a></span>horner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.horner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate univariate polynomial using Horner's method. </p>
<p>I.e., take A + Bx + Cx^2 + Dx^3 and evaluate it as A + x(B + x(C + x(D)))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A numpy array of values at which to evaluate the polynomial. </td></tr>
    <tr><td class="paramname">coef</td><td>Polynomial coefficients of increasing powers of x. </td></tr>
    <tr><td class="paramname">dtype</td><td>Optionally specify the dtype of the return array. [default: None] <pre class="fragment">@returns a numpy array of the evaluated polynomial.  Will be the same shape as x.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47733db76293916f0ec76ab2ea965230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47733db76293916f0ec76ab2ea965230">&#9670;&nbsp;</a></span>horner2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.horner2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate bivariate polynomial using nested Horner's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A numpy array of the x values at which to evaluate the polynomial. </td></tr>
    <tr><td class="paramname">y</td><td>A numpy array of the y values at which to evaluate the polynomial. </td></tr>
    <tr><td class="paramname">coefs</td><td>2D array-like of coefficients in increasing powers of x and y. The first axis corresponds to increasing the power of y, and the second to increasing the power of x. </td></tr>
    <tr><td class="paramname">dtype</td><td>Optionally specify the dtype of the return array. [default: None] <pre class="fragment">@returns a numpy array of the evaluated polynomial.  Will be the same shape as x and y.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1eaa61b14743f05cbfa4b90c9f23817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eaa61b14743f05cbfa4b90c9f23817">&#9670;&nbsp;</a></span>interleaveImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.interleaveImages </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_flux</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suppress_warnings</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>catch_offset_errors</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the pixel values from two or more images and into a single larger image. </p>
<p>This routine converts a list of images taken at a series of (uniform) dither offsets into a single higher resolution image, where the value in each final pixel is the observed pixel value from exactly one of the original images. It can be used to build a Nyquist-sampled image from a set of images that were observed with pixels larger than the Nyquist scale.</p>
<p>In the original observed images, the integration of the surface brightness over the pixels is equivalent to convolution by the pixel profile and then sampling at the centers of the pixels. This procedure simulates an observation sampled at a higher resolution than the original images, while retaining the original pixel convolution.</p>
<p>Such an image can be obtained in a fairly simple manner in simulations of surface brightness profiles by convolving them explicitly with the native pixel response and setting a lower sampling scale (or higher sampling rate) using the &lsquo;pixel_scale&rsquo; argument in <a class="el" href="namespacegalsim_1_1gsobject.html#ae6973ff2ec617b3bce96aef8989afc41" title="Draw this profile into an Image by shooting photons. ">drawImage()</a> routine and setting the &lsquo;method&rsquo; parameter to &lsquo;no_pixel&rsquo;.</p>
<p>However, pixel level detector effects can be included only on images drawn at the native pixel scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include the effects of detector non-idealities can be obtained by drawing multiple undersampled images (with the detector effects included) that are offset from each other by a fraction of a pixel.</p>
<p>This is similar to other procedures that build a higher resolution image from a set of low resolution images, such as MultiDrizzle and IMCOM. A disadvantage of this routine compared to ther others is that the images must be offset in equal steps in each direction. This is difficult to acheive with real observations but can be precisely acheived in a series of simulated images.</p>
<p>An advantage of this procedure is that the noise in the final image is not correlated as the pixel values are each taken from just a single input image. Thus, this routine preserves the noise properties of the pixels.</p>
<p>Here's an example script using this routine:</p>
<h2>Interleaving two Gaussian images along the x-axis </h2>
<pre class="fragment">&gt;&gt;&gt; n = 2
&gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)
&gt;&gt;&gt; DX = numpy.arange(0.0,1.0,1./n)
&gt;&gt;&gt; DX -= DX.mean()
&gt;&gt;&gt; im_list, offsets = [], []
&gt;&gt;&gt; for dx in DX:
    ... offset = galsim.PositionD(dx,0.0)
    ... offsets.append(offset)
    ... im = galsim.Image(16,16)
    ... gal.drawImage(image=im,offset=offset,scale=1.0)
    ... im.applyNonlinearity(lambda x: x - 0.01*x**2) # detector effects
    ... im_list.append(im)
&gt;&gt;&gt; img = galsim.utilities.interleaveImages(im_list=im_list,N=(n,1),offsets=offsets)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im_list</td><td>A list containing the galsim.Image instances to be interleaved. </td></tr>
    <tr><td class="paramname">N</td><td>Number of images to interleave in either directions. It can be of type &lsquo;int&rsquo; if equal number of images are interleaved in both directions or a list or tuple of two integers, containing the number of images in x and y directions respectively. </td></tr>
    <tr><td class="paramname">offsets</td><td>A list containing the offsets as galsim.PositionD instances corresponding to every image in &lsquo;im_list&rsquo;. The offsets must be spaced equally and must span an entire pixel area. The offset values must be symmetric around zero, hence taking positive and negative values, with upper and lower limits of +0.5 and -0.5 (limit values excluded). </td></tr>
    <tr><td class="paramname">add_flux</td><td>Should the routine add the fluxes of all the images (True) or average them (False)? [default: True] </td></tr>
    <tr><td class="paramname">suppress_warnings</td><td>Suppresses the warnings about the pixel scale of the output, if True. [default: False] </td></tr>
    <tr><td class="paramname">catch_offset_errors</td><td>Checks for the consistency of <code>offsets</code> with <code>N</code> and raises Errors if inconsistencies found (True). Recommended, but could slow down the routine a little. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interleaved image </dd></dl>

</div>
</div>
<a id="aa903eb2a1996461798e389862df86309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa903eb2a1996461798e389862df86309">&#9670;&nbsp;</a></span>kxky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.kxky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array_shape</em> = <code>(256,&#160;256)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape. </p>
<p>Uses the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> conventions for Fourier space, so <code>k</code> varies in approximate range (-pi, pi]. Uses the most common DFT element ordering conventions (and those of FFTW), so that <code>(0, 0)</code> array element corresponds to <code>(kx, ky) = (0, 0)</code>.</p>
<p>See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here, but misses a factor of pi.</p>
<p>Adopts NumPy array index ordering so that the trailing axis corresponds to <code>kx</code>, rather than the leading axis as would be expected in IDL/Fortran. See docstring for numpy.meshgrid which also uses this convention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_shape</td><td>The NumPy array shape desired for <code>kx, ky</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5502072778652153adf7b62d061f83c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5502072778652153adf7b62d061f83c7">&#9670;&nbsp;</a></span>listify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.listify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn argument into a list if not already iterable. </p>

</div>
</div>
<a id="a2847aa29baeb6ae446ea195d9a528e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2847aa29baeb6ae446ea195d9a528e80">&#9670;&nbsp;</a></span>math_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.math_eval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_modules</em> = <code>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a string that may include numpy, np, or math commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to evaluate </td></tr>
    <tr><td class="paramname">other_modules</td><td>Other modules in addition to numpy, np, math to import as well. Should be given as a list of strings. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever the string evaluates to. </dd></dl>

</div>
</div>
<a id="adb0a3eb3fcb0585b5dfc2f6d200d3422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0a3eb3fcb0585b5dfc2f6d200d3422">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3b0ba2ce1f706475c4ee33d44d9ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b0ba2ce1f706475c4ee33d44d9ae89">&#9670;&nbsp;</a></span>nCr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.nCr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combinations. </p>
<p>I.e., the number of ways to choose <code>r</code> distiguishable things from <code>n</code> distinguishable things. </p>

</div>
</div>
<a id="a18ade429d89b7f6db0b705638978a1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ade429d89b7f6db0b705638978a1f8">&#9670;&nbsp;</a></span>old_thin_tabulated_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.old_thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input <code>x,f</code> values can be lists, NumPy arrays, or really anything that can be converted to a NumPy array. The new lists will be output as python lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>x</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The <code>f</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. [default: 1.e-4] </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of <code>x</code> be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists <code>(x_new, y_new)</code> with the thinned tabulation. </dd></dl>

</div>
</div>
<a id="a9ed5fa9c179421d0064d1e8e939411f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed5fa9c179421d0064d1e8e939411f9">&#9670;&nbsp;</a></span>parse_pos_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.parse_pos_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integer</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the args and kwargs of a function call to be some kind of position. </p>
<p>We allow four options: </p><pre class="fragment">f(x,y)
f(galsim.PositionD(x,y)) or f(galsim.PositionI(x,y))
f( (x,y) )  (or any indexable thing)
f(name1=x, name2=y)
</pre><p>If the inputs must be integers, set <code>integer=True</code>. If there are other args/kwargs to parse after these, then their names should be be given as the parameter <code>others</code>, which are passed back in a tuple after the position. </p>

</div>
</div>
<a id="a8913170afc5617be17478cac3ddd68ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913170afc5617be17478cac3ddd68ef">&#9670;&nbsp;</a></span>printoptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.printoptions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a0357fc12802dc70e7749aaf3867fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0357fc12802dc70e7749aaf3867fc">&#9670;&nbsp;</a></span>rand_arr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rand_arr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deviate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make a 2d array of random deviates (of any sort). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A list of length 2, indicating the desired 2d array dimensions </td></tr>
    <tr><td class="paramname">deviate</td><td>Any GalSim deviate (see <a class="el" href="random_8py.html" title="Addition of docstrings to the Random deviate classes at the Python layer and definition of the DistDe...">random.py</a>) such as <a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.). ">UniformDeviate</a>, <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution. ">GaussianDeviate</a>, etc. to be used to generate random numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NumPy array of the desired dimensions with random numbers generated using the supplied deviate. </dd></dl>

</div>
</div>
<a id="a43a53067a6269fc4a150f25a7d5fc476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a53067a6269fc4a150f25a7d5fc476">&#9670;&nbsp;</a></span>rand_with_replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rand_with_replacement </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_n_rng_calls</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select some number of random choices from a list, with replacement, using a supplied RNG. </p>
<p><code>n</code> random choices with replacement are made assuming that those choices should range from 0 to <code>n_choices</code>-1, so they can be used as indices in a list/array. If <code>weight</code> is supplied, then it should be an array of length <code>n_choices</code> that ranges from 0-1, and can be used to make weighted choices from the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of random selections to make. </td></tr>
    <tr><td class="paramname">n_choices</td><td>Number of entries from which to choose. </td></tr>
    <tr><td class="paramname">rng</td><td>RNG to use. Should be a <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">galsim.BaseDeviate</a>. </td></tr>
    <tr><td class="paramname">weight</td><td>Optional list of weight factors to use for weighting the selection of random indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NumPy array of length <code>n</code> containing the integer-valued indices that were selected. </dd></dl>

</div>
</div>
<a id="abce8280a02c70e4267318a1e44416fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce8280a02c70e4267318a1e44416fd2">&#9670;&nbsp;</a></span>roll2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.roll2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The NumPy array to be circular shifted. </td></tr>
    <tr><td class="paramname">shape</td><td>(iroll, jroll) The roll in the i and j dimensions, respectively. <pre class="fragment">@returns the rolled image.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fcb65492635b09b9dff27d7a12ad92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcb65492635b09b9dff27d7a12ad92a">&#9670;&nbsp;</a></span>rotate_xy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rotate_xy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>NumPy array of input <code>x</code> coordinates </td></tr>
    <tr><td class="paramname">y</td><td>NumPy array of input <code>y</code> coordinates </td></tr>
    <tr><td class="paramname">theta</td><td>Rotation angle (+ve counter clockwise) as an Angle instance <pre class="fragment">@return the rotated coordinates `(x_rot,y_rot)`.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88375098001fff5fe23c210ebe594025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88375098001fff5fe23c210ebe594025">&#9670;&nbsp;</a></span>structure_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.structure_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the angularly-averaged structure function of a 2D random field. </p>
<p>The angularly-averaged structure function D(r) of the 2D field phi is defined as:</p>
<p>D(|r|) = &lt;|phi(x) - phi(x+r)|^2&gt;</p>
<p>where the x and r on the RHS are 2D vectors, but the |r| on the LHS is just a scalar length.</p>
<p>The image must have its <code>scale</code> attribute defined. It will be used in the calculations to set the scale of the radial distances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image containing random field realization. <pre class="fragment">@returns      A python callable mapping a separation length r to the estimate of the structure
              function D(r).</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a407a3fbc4fbd9d4a03caa8fe29b531f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407a3fbc4fbd9d4a03caa8fe29b531f1">&#9670;&nbsp;</a></span>thin_tabulated_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim_zeros</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fast_search</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input <code>x,f</code> values can be lists, NumPy arrays, or really anything that can be converted to a NumPy array. The new lists will be output as numpy arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>x</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The <code>f</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. [default: 1.e-4] </td></tr>
    <tr><td class="paramname">trim_zeros</td><td>Remove redundant leading and trailing points where f=0? (The last leading point with f=0 and the first trailing point with f=0 will be retained). Note that if both trim_leading_zeros and preserve_range are True, then the only the range of <code>x</code> <em>after</em> zero trimming is preserved. [default: True] </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of <code>x</code> be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) [default: True] </td></tr>
    <tr><td class="paramname">fast_search</td><td>If set to True, then the underlying algorithm will use a relatively fast O(N) algorithm to select points to include in the thinned approximation. If set to False, then a slower O(N^2) algorithm will be used. We have found that the slower algorithm tends to yield a thinned representation that retains fewer samples while still meeting the relative error requirement. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists <code>(x_new, y_new)</code> with the thinned tabulation. </dd></dl>

</div>
</div>
<a id="a8aae8f7ef417c486f0a42e095eed1ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aae8f7ef417c486f0a42e095eed1ef1">&#9670;&nbsp;</a></span>unweighted_moments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.unweighted_moments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes unweighted 0th, 1st, and 2nd moments in image coordinates. </p>
<p>Respects image bounds, but ignores any scale or wcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image from which to compute moments </td></tr>
    <tr><td class="paramname">origin</td><td>Optional origin in image coordinates used to compute Mx and My [default: galsim.PositionD(0, 0)]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dict with entries for [M0, Mx, My, Mxx, Myy, Mxy] </dd></dl>

</div>
</div>
<a id="a14bbb93028dc0e0b9c202068390efed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bbb93028dc0e0b9c202068390efed7">&#9670;&nbsp;</a></span>unweighted_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.unweighted_shape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes unweighted second moment size and ellipticity given either an image or a dict of unweighted moments. </p>
<p>The size is: rsqr = Mxx+Myy The ellipticities are: e1 = (Mxx-Myy) / rsqr e2 = 2*Mxy / rsqr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Either a galsim.Image or the output of unweighted_moments(image). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dict with entries for [rsqr, e1, e2] </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14</small></address>
</body>
</html>
