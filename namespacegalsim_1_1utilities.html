<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim.utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_attribute_dict.html">AttributeDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary class that allows for easy initialization and refs to key values via attributes.  <a href="classgalsim_1_1utilities_1_1_attribute_dict.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_l_r_u___cache.html">LRU_Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified Least Recently Used Cache.  <a href="classgalsim_1_1utilities_1_1_l_r_u___cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_simple_generator.html">SimpleGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that is constructed with an arbitrary object.  <a href="classgalsim_1_1utilities_1_1_simple_generator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13e9d483f84e5d442b47384d26f5f65b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a13e9d483f84e5d442b47384d26f5f65b">roll2d</a></td></tr>
<tr class="memdesc:a13e9d483f84e5d442b47384d26f5f65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently.  <a href="#a13e9d483f84e5d442b47384d26f5f65b">More...</a><br/></td></tr>
<tr class="separator:a13e9d483f84e5d442b47384d26f5f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ae3d1586e7c70ecfd9582b71f6f5147ab">kxky</a></td></tr>
<tr class="memdesc:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape.  <a href="#ae3d1586e7c70ecfd9582b71f6f5147ab">More...</a><br/></td></tr>
<tr class="separator:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5623a48fc511636b486d42816ba940"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a9e5623a48fc511636b486d42816ba940">g1g2_to_e1e2</a></td></tr>
<tr class="memdesc:a9e5623a48fc511636b486d42816ba940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>.  <a href="#a9e5623a48fc511636b486d42816ba940">More...</a><br/></td></tr>
<tr class="separator:a9e5623a48fc511636b486d42816ba940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e66b2539898963681cd1bf1fba0214"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af0e66b2539898963681cd1bf1fba0214">rotate_xy</a></td></tr>
<tr class="memdesc:af0e66b2539898963681cd1bf1fba0214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system.  <a href="#af0e66b2539898963681cd1bf1fba0214">More...</a><br/></td></tr>
<tr class="separator:af0e66b2539898963681cd1bf1fba0214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af424a90c9e1c9f64eaaf4f52bcb1aceb">parse_pos_args</a></td></tr>
<tr class="memdesc:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the args and kwargs of a function call to be some kind of position.  <a href="#af424a90c9e1c9f64eaaf4f52bcb1aceb">More...</a><br/></td></tr>
<tr class="separator:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd8593ea30d16263c2f03e1147b5b27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#abbd8593ea30d16263c2f03e1147b5b27">rand_arr</a></td></tr>
<tr class="memdesc:abbd8593ea30d16263c2f03e1147b5b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 2d array of random deviates (of any sort).  <a href="#abbd8593ea30d16263c2f03e1147b5b27">More...</a><br/></td></tr>
<tr class="separator:abbd8593ea30d16263c2f03e1147b5b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0f1e1e39e1ac7f446f278746918992"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#adf0f1e1e39e1ac7f446f278746918992">convert_interpolant</a></td></tr>
<tr class="memdesc:adf0f1e1e39e1ac7f446f278746918992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string.  <a href="#adf0f1e1e39e1ac7f446f278746918992">More...</a><br/></td></tr>
<tr class="separator:adf0f1e1e39e1ac7f446f278746918992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726162f079025bf5e5a622702d001ad7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a726162f079025bf5e5a622702d001ad7">thin_tabulated_values</a></td></tr>
<tr class="memdesc:a726162f079025bf5e5a622702d001ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a726162f079025bf5e5a622702d001ad7">More...</a><br/></td></tr>
<tr class="separator:a726162f079025bf5e5a622702d001ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2760dcbfc4ece3e6177ee35a187ae1db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a2760dcbfc4ece3e6177ee35a187ae1db">old_thin_tabulated_values</a></td></tr>
<tr class="memdesc:a2760dcbfc4ece3e6177ee35a187ae1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a2760dcbfc4ece3e6177ee35a187ae1db">More...</a><br/></td></tr>
<tr class="separator:a2760dcbfc4ece3e6177ee35a187ae1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f44699b20e12fdf56532d37dd29c4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ab9f44699b20e12fdf56532d37dd29c4e">deInterleaveImage</a></td></tr>
<tr class="memdesc:ab9f44699b20e12fdf56532d37dd29c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The routine to do the opposite of what 'interleaveImages' routine does.  <a href="#ab9f44699b20e12fdf56532d37dd29c4e">More...</a><br/></td></tr>
<tr class="separator:ab9f44699b20e12fdf56532d37dd29c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d0acc084bdcb8cb85892463661233"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aaf4d0acc084bdcb8cb85892463661233">interleaveImages</a></td></tr>
<tr class="memdesc:aaf4d0acc084bdcb8cb85892463661233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the pixel values from two or more images and into a single larger image.  <a href="#aaf4d0acc084bdcb8cb85892463661233">More...</a><br/></td></tr>
<tr class="separator:aaf4d0acc084bdcb8cb85892463661233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2e1494117e0fe6002e205bb4673343"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a2c2e1494117e0fe6002e205bb4673343">printoptions</a></td></tr>
<tr class="separator:a2c2e1494117e0fe6002e205bb4673343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d05124abd7aeb2585903f31b82caa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aee0d05124abd7aeb2585903f31b82caa">listify</a></td></tr>
<tr class="memdesc:aee0d05124abd7aeb2585903f31b82caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn argument into a list if not already iterable.  <a href="#aee0d05124abd7aeb2585903f31b82caa">More...</a><br/></td></tr>
<tr class="separator:aee0d05124abd7aeb2585903f31b82caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2f282768adf06a13a7348abdd4dfe5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aec2f282768adf06a13a7348abdd4dfe5">lod_to_dol</a></td></tr>
<tr class="memdesc:aec2f282768adf06a13a7348abdd4dfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate dicts from dict of lists (with broadcasting).  <a href="#aec2f282768adf06a13a7348abdd4dfe5">More...</a><br/></td></tr>
<tr class="separator:aec2f282768adf06a13a7348abdd4dfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b126af0ef8f3da36e3a964c1559a2c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a7b126af0ef8f3da36e3a964c1559a2c9">set_func_doc</a></td></tr>
<tr class="memdesc:a7b126af0ef8f3da36e3a964c1559a2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically set a docstring for a given function.  <a href="#a7b126af0ef8f3da36e3a964c1559a2c9">More...</a><br/></td></tr>
<tr class="separator:a7b126af0ef8f3da36e3a964c1559a2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898e9309f6853faa1cfa6be77f23c8ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a898e9309f6853faa1cfa6be77f23c8ea">structure_function</a></td></tr>
<tr class="memdesc:a898e9309f6853faa1cfa6be77f23c8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the angularly-averaged structure function of a 2D random field.  <a href="#a898e9309f6853faa1cfa6be77f23c8ea">More...</a><br/></td></tr>
<tr class="separator:a898e9309f6853faa1cfa6be77f23c8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adf0f1e1e39e1ac7f446f278746918992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.convert_interpolant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string. </p>

</div>
</div>
<a class="anchor" id="ab9f44699b20e12fdf56532d37dd29c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.deInterleaveImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conserve_flux</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suppress_warnings</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The routine to do the opposite of what 'interleaveImages' routine does. </p>
<p>It generates a (uniform) dither sequence of low resolution images from a high resolution image.</p>
<p>Many pixel level detector effects, such as interpixel capacitance, persistence, charge diffusion etc. can be included only on images drawn at the native pixel scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include the effects of detector non-idealities can be obtained by drawing multiple undersampled images (with the detector effects included) that are offset from each other by a fraction of a pixel. If the offsets are uniformly spaced, then images can be combined using 'interleaveImages' into a Nyquist-sampled image.</p>
<p>Drawing multiple low resolution images of a light profile can be a lot slower than drawing a high resolution image of the same profile, even if the total number of pixels is the same. A uniformly offset dither sequence can be extracted from a well-resolved image that is drawn by convolving the surface brightness profile explicitly with the native pixel response and setting a lower sampling scale (or higher sampling rate) using the `pixel_scale' argument in drawImage() routine and setting the `method' parameter to `no_pixel'.</p>
<p>Here is an example script using this routine:</p>
<h2>Interleaving four Gaussian images </h2>
<pre class="fragment">&gt;&gt;&gt; n = 2
&gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)
&gt;&gt;&gt; gal_pix = galsim.Convolve([gal,galsim.Pixel(scale=1.0)])
&gt;&gt;&gt; img = gal_pix.drawImage(gal_pix,scale=1.0/n,method='no_pixel')
&gt;&gt;&gt; im_list, offsets = galsim.utilities.deInterleaveImage(img,N=n)
&gt;&gt;&gt; for im in im_list:
&gt;&gt;&gt;     im.applyNonlinearity(lambda x: x-0.01*x**2) #detector effects
&gt;&gt;&gt; img_new = galsim.utilities.interleaveImages(im_list,N=n,offsets)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input image from which lower resolution images are extracted. </td></tr>
    <tr><td class="paramname">N</td><td>Number of images extracted in either directions. It can be of type 'int' if equal number of images are extracted in both directions or a list or tuple of two integers, containing the number of images in x and y directions respectively. </td></tr>
    <tr><td class="paramname">conserve_flux</td><td>Should the routine output images that have, on average, same total pixel values as the input image (True) or should the pixel values summed over all the images equal the sum of pixel values of the input image (False)? [default: False] </td></tr>
    <tr><td class="paramname">suppress_warnings</td><td>Suppresses the warnings about the pixel scale of the output, if True. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of images and offsets to reconstruct the input image using 'interleaveImages'. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e5623a48fc511636b486d42816ba940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.g1g2_to_e1e2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>. </p>
<p>Here <code>g1</code> and <code>g2</code> are reduced shears, and <code>e1</code> and <code>e2</code> are distortions - see shear.py for definitions of reduced shear and distortion in terms of axis ratios or other ways of specifying ellipses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First reduced shear component </td></tr>
    <tr><td class="paramname">g2</td><td>Second reduced shear component</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding distortions, e1 and e2. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf4d0acc084bdcb8cb85892463661233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.interleaveImages </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_flux</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suppress_warnings</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>catch_offset_errors</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the pixel values from two or more images and into a single larger image. </p>
<p>This routine converts a list of images taken at a series of (uniform) dither offsets into a single higher resolution image, where the value in each final pixel is the observed pixel value from exactly one of the original images. It can be used to build a Nyquist-sampled image from a set of images that were observed with pixels larger than the Nyquist scale.</p>
<p>In the original observed images, the integration of the surface brightness over the pixels is equivalent to convolution by the pixel profile and then sampling at the centers of the pixels. This procedure simulates an observation sampled at a higher resolution than the original images, while retaining the original pixel convolution.</p>
<p>Such an image can be obtained in a fairly simple manner in simulations of surface brightness profiles by convolving them explicitly with the native pixel response and setting a lower sampling scale (or higher sampling rate) using the `pixel_scale' argument in drawImage() routine and setting the `method' parameter to `no_pixel'.</p>
<p>However, pixel level detector effects can be included only on images drawn at the native pixel scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include the effects of detector non-idealities can be obtained by drawing multiple undersampled images (with the detector effects included) that are offset from each other by a fraction of a pixel.</p>
<p>This is similar to other procedures that build a higher resolution image from a set of low resolution images, such as MultiDrizzle and IMCOM. A disadvantage of this routine compared to ther others is that the images must be offset in equal steps in each direction. This is difficult to acheive with real observations but can be precisely acheived in a series of simulated images.</p>
<p>An advantage of this procedure is that the noise in the final image is not correlated as the pixel values are each taken from just a single input image. Thus, this routine preserves the noise properties of the pixels.</p>
<p>Here's an example script using this routine:</p>
<h2>Interleaving two Gaussian images along the x-axis </h2>
<pre class="fragment">&gt;&gt;&gt; n = 2
&gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)
&gt;&gt;&gt; DX = numpy.arange(0.0,1.0,1./n)
&gt;&gt;&gt; DX -= DX.mean()
&gt;&gt;&gt; im_list, offsets = [], []
&gt;&gt;&gt; for dx in DX:
    ... offset = galsim.PositionD(dx,0.0)
    ... offsets.append(offset)
    ... im = galsim.Image(16,16)
    ... gal.drawImage(image=im,offset=offset,scale=1.0)
    ... im.applyNonlinearity(lambda x: x - 0.01*x**2) # detector effects
    ... im_list.append(im)
&gt;&gt;&gt; img = galsim.utilities.interleaveImages(im_list=im_list,N=(n,1),offsets=offsets)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im_list</td><td>A list containing the galsim.Image instances to be interleaved. </td></tr>
    <tr><td class="paramname">N</td><td>Number of images to interleave in either directions. It can be of type `int' if equal number of images are interleaved in both directions or a list or tuple of two integers, containing the number of images in x and y directions respectively. </td></tr>
    <tr><td class="paramname">offsets</td><td>A list containing the offsets as galsim.PositionD instances corresponding to every image in `im_list'. The offsets must be spaced equally and must span an entire pixel area. The offset values must be symmetric around zero, hence taking positive and negative values, with upper and lower limits of +0.5 and -0.5 (limit values excluded). </td></tr>
    <tr><td class="paramname">add_flux</td><td>Should the routine add the fluxes of all the images (True) or average them (False)? [default: True] </td></tr>
    <tr><td class="paramname">suppress_warnings</td><td>Suppresses the warnings about the pixel scale of the output, if True. [default: False] </td></tr>
    <tr><td class="paramname">catch_offset_errors</td><td>Checks for the consistency of <code>offsets</code> with <code>N</code> and raises Errors if inconsistencies found (True). Recommended, but could slow down the routine a little. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interleaved image </dd></dl>

</div>
</div>
<a class="anchor" id="ae3d1586e7c70ecfd9582b71f6f5147ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.kxky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array_shape</em> = <code>(256,&#160;256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape. </p>
<p>Uses the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> conventions for Fourier space, so <code>k</code> varies in approximate range (-pi, pi]. Uses the most common DFT element ordering conventions (and those of FFTW), so that <code>(0, 0)</code> array element corresponds to <code>(kx, ky) = (0, 0)</code>.</p>
<p>See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here, but misses a factor of pi.</p>
<p>Adopts NumPy array index ordering so that the trailing axis corresponds to <code>kx</code>, rather than the leading axis as would be expected in IDL/Fortran. See docstring for numpy.meshgrid which also uses this convention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_shape</td><td>The NumPy array shape desired for <code>kx, ky</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee0d05124abd7aeb2585903f31b82caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.listify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn argument into a list if not already iterable. </p>

</div>
</div>
<a class="anchor" id="aec2f282768adf06a13a7348abdd4dfe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.lod_to_dol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate dicts from dict of lists (with broadcasting). </p>
<p>Specifically, generate "scalar-valued" kwargs dictionaries from a kwarg dictionary with values that are length-N lists, or possibly length-1 lists or scalars that should be broadcasted up to length-N lists. </p>

</div>
</div>
<a class="anchor" id="a2760dcbfc4ece3e6177ee35a187ae1db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.old_thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input <code>x,f</code> values can be lists, NumPy arrays, or really anything that can be converted to a NumPy array. The new lists will be output as python lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>x</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The <code>f</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. [default: 1.e-4] </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of <code>x</code> be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists <code>(x_new, y_new)</code> with the thinned tabulation. </dd></dl>

</div>
</div>
<a class="anchor" id="af424a90c9e1c9f64eaaf4f52bcb1aceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.parse_pos_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integer</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the args and kwargs of a function call to be some kind of position. </p>
<p>We allow four options: </p>
<pre class="fragment">f(x,y)
f(galsim.PositionD(x,y)) or f(galsim.PositionI(x,y))
f( (x,y) )  (or any indexable thing)
f(name1=x, name2=y)
</pre><p>If the inputs must be integers, set <code>integer=True</code>. If there are other args/kwargs to parse after these, then their names should be be given as the parameter <code>others</code>, which are passed back in a tuple after the position. </p>

</div>
</div>
<a class="anchor" id="a2c2e1494117e0fe6002e205bb4673343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.printoptions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbd8593ea30d16263c2f03e1147b5b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rand_arr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deviate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make a 2d array of random deviates (of any sort). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A list of length 2, indicating the desired 2d array dimensions </td></tr>
    <tr><td class="paramname">deviate</td><td>Any GalSim deviate (see random.py) such as <a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.). ">UniformDeviate</a>, <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution. ">GaussianDeviate</a>, etc. to be used to generate random numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NumPy array of the desired dimensions with random numbers generated using the supplied deviate. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e9d483f84e5d442b47384d26f5f65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.roll2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The NumPy array to be circular shifted. </td></tr>
    <tr><td class="paramname">shape</td><td>(iroll, jroll) The roll in the i and j dimensions, respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rolled image. </dd></dl>

</div>
</div>
<a class="anchor" id="af0e66b2539898963681cd1bf1fba0214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rotate_xy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>NumPy array of input <code>x</code> coordinates </td></tr>
    <tr><td class="paramname">y</td><td>NumPy array of input <code>y</code> coordinates </td></tr>
    <tr><td class="paramname">theta</td><td>Rotation angle (+ve counter clockwise) as an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated coordinates <code>(x_rot,y_rot)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b126af0ef8f3da36e3a964c1559a2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.set_func_doc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically set a docstring for a given function. </p>
<p>We use this in GalSim to add docstrings to some functions that are wrapped from C++. It turns out this tends to be easier than writing the doc strings in the C++ layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to which a docstring is to be added. </td></tr>
    <tr><td class="paramname">doc</td><td>The doc string to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a898e9309f6853faa1cfa6be77f23c8ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.structure_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the angularly-averaged structure function of a 2D random field. </p>
<p>The angularly-averaged structure function D(r) of the 2D field phi is defined as:</p>
<p>D(|r|) = &lt;|phi(x) - phi(x+r)|^2&gt;</p>
<p>where the x and r on the RHS are 2D vectors, but the |r| on the LHS is just a scalar length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image containing random field realization. The <code>.scale</code> attribute here <em>is</em> used in the calculation. If it's <code>None</code>, then the code will use 1.0 for the scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A python callable mapping a separation length r to the estimate of the structure function D(r). </dd></dl>

</div>
</div>
<a class="anchor" id="a726162f079025bf5e5a622702d001ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim_zeros</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fast_search</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input <code>x,f</code> values can be lists, NumPy arrays, or really anything that can be converted to a NumPy array. The new lists will be output as numpy arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>x</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The <code>f</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. [default: 1.e-4] </td></tr>
    <tr><td class="paramname">trim_zeros</td><td>Remove redundant leading and trailing points where f=0? (The last leading point with f=0 and the first trailing point with f=0 will be retained). Note that if both trim_leading_zeros and preserve_range are True, then the only the range of <code>x</code> <em>after</em> zero trimming is preserved. [default: True] </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of <code>x</code> be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) [default: True] </td></tr>
    <tr><td class="paramname">fast_search</td><td>If set to True, then the underlying algorithm will use a relatively fast O(N) algorithm to select points to include in the thinned approximation. If set to False, then a slower O(N^2) algorithm will be used. We have found that the slower algorithm tends to yield a thinned representation that retains fewer samples while still meeting the relative error requirement. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists <code>(x_new, y_new)</code> with the thinned tabulation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
