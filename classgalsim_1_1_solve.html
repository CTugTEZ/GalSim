<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim::Solve&lt; F, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="classgalsim_1_1_solve.html">Solve</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgalsim_1_1_solve-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim::Solve&lt; F, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that solves a provided function for a zero.  
 <a href="classgalsim_1_1_solve.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_solve_8h_source.html">Solve.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a033c73ab95526b69899e8acfbc70a1bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a033c73ab95526b69899e8acfbc70a1bf">Solve</a> (const F &amp;func_, T lb_, T ub_)</td></tr>
<tr class="memdesc:a033c73ab95526b69899e8acfbc70a1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor taking the function to solve, and the range (if known).  <a href="#a033c73ab95526b69899e8acfbc70a1bf">More...</a><br/></td></tr>
<tr class="separator:a033c73ab95526b69899e8acfbc70a1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e4aa8293b490d8c99a52b7b58d52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a524e4aa8293b490d8c99a52b7b58d52e">setMaxSteps</a> (int m)</td></tr>
<tr class="memdesc:a524e4aa8293b490d8c99a52b7b58d52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of steps for the solving algorithm to use.  <a href="#a524e4aa8293b490d8c99a52b7b58d52e">More...</a><br/></td></tr>
<tr class="separator:a524e4aa8293b490d8c99a52b7b58d52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c9d52be54fac377abb1359bf190b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a71c9d52be54fac377abb1359bf190b7b">setMethod</a> (<a class="el" href="namespacegalsim.html#afd0a492100e8fe7a03839776dc3c2045">Method</a> m_)</td></tr>
<tr class="memdesc:a71c9d52be54fac377abb1359bf190b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which method to use: Bisect or Brent.  <a href="#a71c9d52be54fac377abb1359bf190b7b">More...</a><br/></td></tr>
<tr class="separator:a71c9d52be54fac377abb1359bf190b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a68dd69f9ee0698408ef825ee6bc68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#ad5a68dd69f9ee0698408ef825ee6bc68">setXTolerance</a> (T tol)</td></tr>
<tr class="memdesc:ad5a68dd69f9ee0698408ef825ee6bc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the tolerance to define when the root is close enough to 0. (abs(x) &lt; tol)  <a href="#ad5a68dd69f9ee0698408ef825ee6bc68">More...</a><br/></td></tr>
<tr class="separator:ad5a68dd69f9ee0698408ef825ee6bc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5146f4a23b994d3399ea057d258b2ec4"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a5146f4a23b994d3399ea057d258b2ec4">getXTolerance</a> () const </td></tr>
<tr class="memdesc:a5146f4a23b994d3399ea057d258b2ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current tolerance.  <a href="#a5146f4a23b994d3399ea057d258b2ec4">More...</a><br/></td></tr>
<tr class="separator:a5146f4a23b994d3399ea057d258b2ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbd1f21c10c4bf6afea688e5f2b7aea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a8bbd1f21c10c4bf6afea688e5f2b7aea">setBounds</a> (T lb, T ub)</td></tr>
<tr class="memdesc:a8bbd1f21c10c4bf6afea688e5f2b7aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds for the search to new values.  <a href="#a8bbd1f21c10c4bf6afea688e5f2b7aea">More...</a><br/></td></tr>
<tr class="separator:a8bbd1f21c10c4bf6afea688e5f2b7aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ce3be2704e6ad7cd970715d5ddb49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#ae13ce3be2704e6ad7cd970715d5ddb49">evaluateBounds</a> () const </td></tr>
<tr class="memdesc:ae13ce3be2704e6ad7cd970715d5ddb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the current bounds have corresponding flower, fupper.  <a href="#ae13ce3be2704e6ad7cd970715d5ddb49">More...</a><br/></td></tr>
<tr class="separator:ae13ce3be2704e6ad7cd970715d5ddb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb39f1fca16eeef8c01861f46dc8378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a7eb39f1fca16eeef8c01861f46dc8378">bracket</a> ()</td></tr>
<tr class="memdesc:a7eb39f1fca16eeef8c01861f46dc8378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hunt for bracket, geometrically expanding range.  <a href="#a7eb39f1fca16eeef8c01861f46dc8378">More...</a><br/></td></tr>
<tr class="separator:a7eb39f1fca16eeef8c01861f46dc8378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd89df920b0b55de6865964263ad47b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#abd89df920b0b55de6865964263ad47b7">bracket1</a> (T &amp;a, T &amp;b, T &amp;fa, T &amp;fb)</td></tr>
<tr class="separator:abd89df920b0b55de6865964263ad47b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09e393edf3722d544f6a6dde4d6d10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#ae09e393edf3722d544f6a6dde4d6d10e">bracketUpper</a> ()</td></tr>
<tr class="memdesc:ae09e393edf3722d544f6a6dde4d6d10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hunt for bracket, geometrically expanding range.  <a href="#ae09e393edf3722d544f6a6dde4d6d10e">More...</a><br/></td></tr>
<tr class="separator:ae09e393edf3722d544f6a6dde4d6d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d0325d664ece6713b79efe3994eacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#ac6d0325d664ece6713b79efe3994eacf">bracketLower</a> ()</td></tr>
<tr class="memdesc:ac6d0325d664ece6713b79efe3994eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hunt for bracket, geometrically expanding range.  <a href="#ac6d0325d664ece6713b79efe3994eacf">More...</a><br/></td></tr>
<tr class="separator:ac6d0325d664ece6713b79efe3994eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c474f6fcd3ddc34f5fe015efccfdc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#af2c474f6fcd3ddc34f5fe015efccfdc7">bracket1WithLimit</a> (T &amp;a, T &amp;b, T &amp;fa, T &amp;fb, T &amp;c)</td></tr>
<tr class="separator:af2c474f6fcd3ddc34f5fe015efccfdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21cd78e673e06860435d6cfafbc9819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#ae21cd78e673e06860435d6cfafbc9819">bracketUpperWithLimit</a> (T upper_limit)</td></tr>
<tr class="memdesc:ae21cd78e673e06860435d6cfafbc9819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hunt for upper bracket, with an upper limit to how far it can go.  <a href="#ae21cd78e673e06860435d6cfafbc9819">More...</a><br/></td></tr>
<tr class="separator:ae21cd78e673e06860435d6cfafbc9819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aed902043c7c3aef488504cbdcd423d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a3aed902043c7c3aef488504cbdcd423d">bracketLowerWithLimit</a> (T lower_limit)</td></tr>
<tr class="memdesc:a3aed902043c7c3aef488504cbdcd423d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hunt for lower bracket, with a lower limit to how far it can go.  <a href="#a3aed902043c7c3aef488504cbdcd423d">More...</a><br/></td></tr>
<tr class="separator:a3aed902043c7c3aef488504cbdcd423d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d443964066d0bcead110c54141c735d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a8d443964066d0bcead110c54141c735d">root</a> () const </td></tr>
<tr class="memdesc:a8d443964066d0bcead110c54141c735d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the root according the the method currently set.  <a href="#a8d443964066d0bcead110c54141c735d">More...</a><br/></td></tr>
<tr class="separator:a8d443964066d0bcead110c54141c735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46716cefe286bf38433060ad5dc6abc2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a46716cefe286bf38433060ad5dc6abc2">bisect</a> () const </td></tr>
<tr class="memdesc:a46716cefe286bf38433060ad5dc6abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple bisection root-finder.  <a href="#a46716cefe286bf38433060ad5dc6abc2">More...</a><br/></td></tr>
<tr class="separator:a46716cefe286bf38433060ad5dc6abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11486be6082cbbf0411b66823c5b4df3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a11486be6082cbbf0411b66823c5b4df3">zbrent</a> () const </td></tr>
<tr class="memdesc:a11486be6082cbbf0411b66823c5b4df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more sophisticated root-finder using Brent's algorithm.  <a href="#a11486be6082cbbf0411b66823c5b4df3">More...</a><br/></td></tr>
<tr class="separator:a11486be6082cbbf0411b66823c5b4df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a44ecb51bd3128f7be2181d6c9068accb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a44ecb51bd3128f7be2181d6c9068accb">getLowerBound</a> () const </td></tr>
<tr class="memdesc:a44ecb51bd3128f7be2181d6c9068accb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current search bounds.  <a href="#a44ecb51bd3128f7be2181d6c9068accb">More...</a><br/></td></tr>
<tr class="separator:a44ecb51bd3128f7be2181d6c9068accb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512172fce3ac9bef97b80e2aedbaedb3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_solve.html#a512172fce3ac9bef97b80e2aedbaedb3">getUpperBound</a> () const </td></tr>
<tr class="separator:a512172fce3ac9bef97b80e2aedbaedb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class F, class T = double&gt;<br/>
class galsim::Solve&lt; F, T &gt;</h3>

<p>A class that solves a provided function for a zero. </p>
<p>The first template argument, F, is the type of the function. Typically you would simple function object that defines the operator() method and use that for F.</p>
<p>The second template argument (optional: default = double) is the type of the arguments to the function.</p>
<p>The solving process is in two parts:</p>
<ol type="1">
<li><p class="startli">First the solution needs to be bracketed.</p>
<p class="startli">This can be done in several ways:</p>
<p class="startli">a) If you know the appropriate range, you can set it in the constructor:</p>
</li>
</ol>
<div class="fragment"><div class="line">Solve&lt;MyFunc&gt; solver(func, x_min, x_max);</div>
</div><!-- fragment --><p>b) If you don't know the range, you can set an initial guess range and let <a class="el" href="classgalsim_1_1_solve.html" title="A class that solves a provided function for a zero. ">Solve</a> expand the range until it finds a range that brackets the solution:</p>
<div class="fragment"><div class="line">Solve&lt;MyFunc&gt; solver(func, x_min, x_max);</div>
<div class="line">solver.bracket()</div>
</div><!-- fragment --><p>c) If you know one end of the range, but not the other you can expand only one side of the range from the initial guess:</p>
<div class="fragment"><div class="line">Solve&lt;MyFunc&gt; solver(func, 0, r_max);</div>
<div class="line">solver.bracketUpper()</div>
</div><!-- fragment --><p>(There is also a corresponding <a class="el" href="classgalsim_1_1_solve.html#ac6d0325d664ece6713b79efe3994eacf" title="Hunt for bracket, geometrically expanding range. ">bracketLower()</a> method.)</p>
<p>d) Sometimes there is a fundamental limit past which you want to make sure that the range doesn't go. e.g. For values that must be positive, you might want to make sure the range doesn't extend past 0.</p>
<p>For this case, there are the following two functions </p>
<div class="fragment"><div class="line">solver.bracketUpperWithLimit(upper_limit)</div>
<div class="line">solver.bracketLowerWithLimit(lower_limit)</div>
</div><!-- fragment --><p>Finally, note that there is nothing in the code that enforces x_min &lt; x_max. If the two limits bracket the code in reverse order, that's ok.</p>
<ol type="1">
<li>The next step is to solve for the root within this range. There are currently two algorithms for doing that: Bisect and Brent. You can tell <a class="el" href="classgalsim_1_1_solve.html" title="A class that solves a provided function for a zero. ">Solve</a> which one to use with:</li>
</ol>
<div class="fragment"><div class="line">solver.setMethod(<a class="code" href="namespacegalsim.html#afd0a492100e8fe7a03839776dc3c2045ac946a08005036040527cbac1b1e1333e">Bisect</a>)</div>
<div class="line">solver.setMethod(<a class="code" href="namespacegalsim.html#afd0a492100e8fe7a03839776dc3c2045a8e06681aaf2baa24b7088035f6d644a3">Brent</a>)</div>
</div><!-- fragment --><p>(In fact, the former is unnecessary, since Biset is the default.)</p>
<p>Then the method <a class="el" href="classgalsim_1_1_solve.html#a8d443964066d0bcead110c54141c735d" title="Find the root according the the method currently set. ">root()</a> will solve for the root in that range.</p>
<p>Typical usage:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyFunc {</div>
<div class="line">    <span class="keywordtype">double</span> operator()(<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> [...] }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MyFunc func;</div>
<div class="line">Solve&lt;MyFunc&gt; solver(func, xmin, xmax);</div>
<div class="line">solver.bracket();         <span class="comment">// If necessary</span></div>
<div class="line">solver.setMethod(<a class="code" href="namespacegalsim.html#afd0a492100e8fe7a03839776dc3c2045a8e06681aaf2baa24b7088035f6d644a3">Brent</a>);  <span class="comment">// If desired</span></div>
<div class="line"><span class="keywordtype">double</span> result = solver.root()</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a033c73ab95526b69899e8acfbc70a1bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::<a class="el" href="classgalsim_1_1_solve.html">Solve</a> </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lb_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ub_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor taking the function to solve, and the range (if known). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a46716cefe286bf38433060ad5dc6abc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bisect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple bisection root-finder. </p>

</div>
</div>
<a class="anchor" id="a7eb39f1fca16eeef8c01861f46dc8378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hunt for bracket, geometrically expanding range. </p>
<p>This version assumes that the root is to the side of the end point that is closer to 0. This will be true if the function is monotonic. </p>

</div>
</div>
<a class="anchor" id="abd89df920b0b55de6865964263ad47b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracket1 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2c474f6fcd3ddc34f5fe015efccfdc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracket1WithLimit </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6d0325d664ece6713b79efe3994eacf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracketLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hunt for bracket, geometrically expanding range. </p>
<p>The opposite of bracketUpper &ndash; only expand to the left. </p>

</div>
</div>
<a class="anchor" id="a3aed902043c7c3aef488504cbdcd423d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracketLowerWithLimit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lower_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hunt for lower bracket, with a lower limit to how far it can go. </p>

</div>
</div>
<a class="anchor" id="ae09e393edf3722d544f6a6dde4d6d10e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracketUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hunt for bracket, geometrically expanding range. </p>
<p>This one only expands to the right for when you know that the lower bound is definitely to the left of the root, but the upper bound might not bracket it. </p>

</div>
</div>
<a class="anchor" id="ae21cd78e673e06860435d6cfafbc9819"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::bracketUpperWithLimit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hunt for upper bracket, with an upper limit to how far it can go. </p>

</div>
</div>
<a class="anchor" id="ae13ce3be2704e6ad7cd970715d5ddb49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::evaluateBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure the current bounds have corresponding flower, fupper. </p>

</div>
</div>
<a class="anchor" id="a44ecb51bd3128f7be2181d6c9068accb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::getLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current search bounds. </p>

</div>
</div>
<a class="anchor" id="a512172fce3ac9bef97b80e2aedbaedb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::getUpperBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5146f4a23b994d3399ea057d258b2ec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::getXTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current tolerance. </p>

</div>
</div>
<a class="anchor" id="a8d443964066d0bcead110c54141c735d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the root according the the method currently set. </p>

</div>
</div>
<a class="anchor" id="a8bbd1f21c10c4bf6afea688e5f2b7aea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::setBounds </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bounds for the search to new values. </p>

</div>
</div>
<a class="anchor" id="a524e4aa8293b490d8c99a52b7b58d52e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::setMaxSteps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of steps for the solving algorithm to use. </p>

</div>
</div>
<a class="anchor" id="a71c9d52be54fac377abb1359bf190b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::setMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegalsim.html#afd0a492100e8fe7a03839776dc3c2045">Method</a>&#160;</td>
          <td class="paramname"><em>m_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set which method to use: Bisect or Brent. </p>

</div>
</div>
<a class="anchor" id="ad5a68dd69f9ee0698408ef825ee6bc68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::setXTolerance </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the tolerance to define when the root is close enough to 0. (abs(x) &lt; tol) </p>

</div>
</div>
<a class="anchor" id="a11486be6082cbbf0411b66823c5b4df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgalsim_1_1_solve.html">galsim::Solve</a>&lt; F, T &gt;::zbrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more sophisticated root-finder using Brent's algorithm. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/galsim/<a class="el" href="_solve_8h_source.html">Solve.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
