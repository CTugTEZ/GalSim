<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.base.Pixel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classgalsim_1_1base_1_1_pixel.html">Pixel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgalsim_1_1base_1_1_pixel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim.base.Pixel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class describing a pixel profile.  
 <a href="classgalsim_1_1base_1_1_pixel.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for galsim.base.Pixel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1base_1_1_pixel.png" usemap="#galsim.base.Pixel_map" alt=""/>
  <map id="galsim.base.Pixel_map" name="galsim.base.Pixel_map">
<area href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. " alt="galsim.base.GSObject" shape="rect" coords="0,56,136,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3a6c13854c6de2710229aaa3f4ec106"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#ad3a6c13854c6de2710229aaa3f4ec106">__init__</a></td></tr>
<tr class="separator:ad3a6c13854c6de2710229aaa3f4ec106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e462952240641aaf2faf4bdf0e13020"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a5e462952240641aaf2faf4bdf0e13020">getScale</a></td></tr>
<tr class="memdesc:a5e462952240641aaf2faf4bdf0e13020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pixel scale.  <a href="#a5e462952240641aaf2faf4bdf0e13020">More...</a><br/></td></tr>
<tr class="separator:a5e462952240641aaf2faf4bdf0e13020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982cc6a557574368a7a08b8d00c4bbb2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a982cc6a557574368a7a08b8d00c4bbb2">scale</a></td></tr>
<tr class="separator:a982cc6a557574368a7a08b8d00c4bbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38606c22888fb021b0eab022af1dc7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#ac38606c22888fb021b0eab022af1dc7f">__eq__</a></td></tr>
<tr class="separator:ac38606c22888fb021b0eab022af1dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505209aa120683e09f945abed6e25c5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a505209aa120683e09f945abed6e25c5b">__hash__</a></td></tr>
<tr class="separator:a505209aa120683e09f945abed6e25c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1354e0f4249428f1f10a52833ac0f9e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a1354e0f4249428f1f10a52833ac0f9e6">__repr__</a></td></tr>
<tr class="separator:a1354e0f4249428f1f10a52833ac0f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447a14597fd8c77cb49ebec7e12ce916"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a447a14597fd8c77cb49ebec7e12ce916">__str__</a></td></tr>
<tr class="separator:a447a14597fd8c77cb49ebec7e12ce916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c372339cdb51586c20e281dfae3a7c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a7c372339cdb51586c20e281dfae3a7c1">separable</a></td></tr>
<tr class="separator:a7c372339cdb51586c20e281dfae3a7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaea743ee14bfc5608142603867b240"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aceaea743ee14bfc5608142603867b240">SED</a></td></tr>
<tr class="separator:aceaea743ee14bfc5608142603867b240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c7fc355ce10a3fc041f27c1eb334f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac49c7fc355ce10a3fc041f27c1eb334f">wave_list</a></td></tr>
<tr class="separator:ac49c7fc355ce10a3fc041f27c1eb334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#abb2f53aa19bbfcc16f980072ef07fc9b">evaluateAtWavelength</a></td></tr>
<tr class="memdesc:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return profile at a given wavelength.  <a href="#abb2f53aa19bbfcc16f980072ef07fc9b">More...</a><br/></td></tr>
<tr class="separator:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2781f482d5599469ba51aea46b5b82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ace2781f482d5599469ba51aea46b5b82">__add__</a></td></tr>
<tr class="separator:ace2781f482d5599469ba51aea46b5b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe7e40fdb14bfcab71133684685e5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a7cfe7e40fdb14bfcab71133684685e5f">__sub__</a></td></tr>
<tr class="separator:a7cfe7e40fdb14bfcab71133684685e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa31d94eb1b6367d8034d4cd2c46cd94b">__mul__</a></td></tr>
<tr class="memdesc:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the flux of the object by the given factor.  <a href="#aa31d94eb1b6367d8034d4cd2c46cd94b">More...</a><br/></td></tr>
<tr class="separator:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a27f25c7faffd8c29a45477abc21459"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a1a27f25c7faffd8c29a45477abc21459">__rmul__</a></td></tr>
<tr class="memdesc:a1a27f25c7faffd8c29a45477abc21459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * other.  <a href="#a1a27f25c7faffd8c29a45477abc21459">More...</a><br/></td></tr>
<tr class="separator:a1a27f25c7faffd8c29a45477abc21459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d9f8b408ee4582d170c760c533d98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a182d9f8b408ee4582d170c760c533d98">__div__</a></td></tr>
<tr class="memdesc:a182d9f8b408ee4582d170c760c533d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * (1/other)  <a href="#a182d9f8b408ee4582d170c760c533d98">More...</a><br/></td></tr>
<tr class="separator:a182d9f8b408ee4582d170c760c533d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf331fe434ce3c71b64ce2745d0b75ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#adf331fe434ce3c71b64ce2745d0b75ca">__truediv__</a></td></tr>
<tr class="memdesc:adf331fe434ce3c71b64ce2745d0b75ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * (1/other)  <a href="#adf331fe434ce3c71b64ce2745d0b75ca">More...</a><br/></td></tr>
<tr class="separator:adf331fe434ce3c71b64ce2745d0b75ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa0b398d4b0fca70211e4a73f81ea7e1a">copy</a></td></tr>
<tr class="memdesc:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of an object.  <a href="#aa0b398d4b0fca70211e4a73f81ea7e1a">More...</a><br/></td></tr>
<tr class="separator:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab9d51f34703ced5be1592e112605ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a4ab9d51f34703ced5be1592e112605ff">maxK</a></td></tr>
<tr class="memdesc:a4ab9d51f34703ced5be1592e112605ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value of k beyond which aliasing can be neglected.  <a href="#a4ab9d51f34703ced5be1592e112605ff">More...</a><br/></td></tr>
<tr class="separator:a4ab9d51f34703ced5be1592e112605ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95676589d95590c2ce593adcf4f4198"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ab95676589d95590c2ce593adcf4f4198">nyquistScale</a></td></tr>
<tr class="memdesc:ab95676589d95590c2ce593adcf4f4198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Image pixel spacing that does not alias maxK.  <a href="#ab95676589d95590c2ce593adcf4f4198">More...</a><br/></td></tr>
<tr class="separator:ab95676589d95590c2ce593adcf4f4198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5da3e499f3c00def5f7f54cab532f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae8b5da3e499f3c00def5f7f54cab532f">stepK</a></td></tr>
<tr class="memdesc:ae8b5da3e499f3c00def5f7f54cab532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sampling in k space necessary to avoid folding of image in x space.  <a href="#ae8b5da3e499f3c00def5f7f54cab532f">More...</a><br/></td></tr>
<tr class="separator:ae8b5da3e499f3c00def5f7f54cab532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f480514538e924d29af411563384a6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a4f480514538e924d29af411563384a6d">hasHardEdges</a></td></tr>
<tr class="memdesc:a4f480514538e924d29af411563384a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain.  <a href="#a4f480514538e924d29af411563384a6d">More...</a><br/></td></tr>
<tr class="separator:a4f480514538e924d29af411563384a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a109bc7c81be65f8fc5d5ec32e6d0c0df">isAxisymmetric</a></td></tr>
<tr class="memdesc:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if axially symmetric: affects efficiency of evaluation.  <a href="#a109bc7c81be65f8fc5d5ec32e6d0c0df">More...</a><br/></td></tr>
<tr class="separator:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c7778e707ab11a75a1f5877aa76ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a671c7778e707ab11a75a1f5877aa76ff">isAnalyticX</a></td></tr>
<tr class="memdesc:a671c7778e707ab11a75a1f5877aa76ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#a671c7778e707ab11a75a1f5877aa76ff">More...</a><br/></td></tr>
<tr class="separator:a671c7778e707ab11a75a1f5877aa76ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad883087f48bb56d90612d940dd60a7ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ad883087f48bb56d90612d940dd60a7ab">isAnalyticK</a></td></tr>
<tr class="memdesc:ad883087f48bb56d90612d940dd60a7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#ad883087f48bb56d90612d940dd60a7ab">More...</a><br/></td></tr>
<tr class="separator:ad883087f48bb56d90612d940dd60a7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a0bb72927fce3c765a9580de656d1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a08a0bb72927fce3c765a9580de656d1a">centroid</a></td></tr>
<tr class="memdesc:a08a0bb72927fce3c765a9580de656d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>.  <a href="#a08a0bb72927fce3c765a9580de656d1a">More...</a><br/></td></tr>
<tr class="separator:a08a0bb72927fce3c765a9580de656d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d8ce421ecd90080bdcaaf6890aed8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8">getFlux</a></td></tr>
<tr class="memdesc:a662d8ce421ecd90080bdcaaf6890aed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flux of the object.  <a href="#a662d8ce421ecd90080bdcaaf6890aed8">More...</a><br/></td></tr>
<tr class="separator:a662d8ce421ecd90080bdcaaf6890aed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243ddb524351768f33f6dbd3c594917"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa243ddb524351768f33f6dbd3c594917">getGSParams</a></td></tr>
<tr class="memdesc:aa243ddb524351768f33f6dbd3c594917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> for the object.  <a href="#aa243ddb524351768f33f6dbd3c594917">More...</a><br/></td></tr>
<tr class="separator:aa243ddb524351768f33f6dbd3c594917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d908b3050ba0457c079a343d38e2dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a36d908b3050ba0457c079a343d38e2dd">calculateHLR</a></td></tr>
<tr class="memdesc:a36d908b3050ba0457c079a343d38e2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the half-light radius of the object.  <a href="#a36d908b3050ba0457c079a343d38e2dd">More...</a><br/></td></tr>
<tr class="separator:a36d908b3050ba0457c079a343d38e2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9740f23217a1e1791862633036f1cd7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a9740f23217a1e1791862633036f1cd7f">calculateMomentRadius</a></td></tr>
<tr class="memdesc:a9740f23217a1e1791862633036f1cd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the radius based on unweighted second moments.  <a href="#a9740f23217a1e1791862633036f1cd7f">More...</a><br/></td></tr>
<tr class="separator:a9740f23217a1e1791862633036f1cd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3812e25f78dc7a5d6d21cd29298072ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3812e25f78dc7a5d6d21cd29298072ac">calculateFWHM</a></td></tr>
<tr class="memdesc:a3812e25f78dc7a5d6d21cd29298072ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full-width half-maximum (FWHM) of the object.  <a href="#a3812e25f78dc7a5d6d21cd29298072ac">More...</a><br/></td></tr>
<tr class="separator:a3812e25f78dc7a5d6d21cd29298072ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e31527de68d7072651399aeda5209d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a38e31527de68d7072651399aeda5209d">flux</a></td></tr>
<tr class="separator:a38e31527de68d7072651399aeda5209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c07d68ffe9123beae4d7217f7f57a18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a5c07d68ffe9123beae4d7217f7f57a18">gsparams</a></td></tr>
<tr class="separator:a5c07d68ffe9123beae4d7217f7f57a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30355af05f88c36f078099b6bb792e1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c">xValue</a></td></tr>
<tr class="memdesc:a30355af05f88c36f078099b6bb792e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in real space.  <a href="#a30355af05f88c36f078099b6bb792e1c">More...</a><br/></td></tr>
<tr class="separator:a30355af05f88c36f078099b6bb792e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8652894487904b797d7752651b54507"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac8652894487904b797d7752651b54507">kValue</a></td></tr>
<tr class="memdesc:ac8652894487904b797d7752651b54507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in k space.  <a href="#ac8652894487904b797d7752651b54507">More...</a><br/></td></tr>
<tr class="separator:ac8652894487904b797d7752651b54507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3f12b6158381ca5ef6da8e94f701f3e5">withFlux</a></td></tr>
<tr class="memdesc:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a different flux.  <a href="#a3f12b6158381ca5ef6da8e94f701f3e5">More...</a><br/></td></tr>
<tr class="separator:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5b330e1c7565a2bb56258127d6149"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a21a5b330e1c7565a2bb56258127d6149">withScaledFlux</a></td></tr>
<tr class="memdesc:a21a5b330e1c7565a2bb56258127d6149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>.  <a href="#a21a5b330e1c7565a2bb56258127d6149">More...</a><br/></td></tr>
<tr class="separator:a21a5b330e1c7565a2bb56258127d6149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582e45c3a235ce1be2f58bfb2070ef15"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15">expand</a></td></tr>
<tr class="memdesc:a582e45c3a235ce1be2f58bfb2070ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness.  <a href="#a582e45c3a235ce1be2f58bfb2070ef15">More...</a><br/></td></tr>
<tr class="separator:a582e45c3a235ce1be2f58bfb2070ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f">dilate</a></td></tr>
<tr class="memdesc:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux.  <a href="#a0e80b6924c48e9708dd9e475f3b48b5f">More...</a><br/></td></tr>
<tr class="separator:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64da7ce1c4165ba048300fede29943"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943">magnify</a></td></tr>
<tr class="memdesc:aac64da7ce1c4165ba048300fede29943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by <code>mu</code> at fixed surface brightness.  <a href="#aac64da7ce1c4165ba048300fede29943">More...</a><br/></td></tr>
<tr class="separator:aac64da7ce1c4165ba048300fede29943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ac16f75958b4a14246e944662ce3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f">shear</a></td></tr>
<tr class="memdesc:acc3ac16f75958b4a14246e944662ce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an area-preserving shear applied to it.  <a href="#acc3ac16f75958b4a14246e944662ce3f">More...</a><br/></td></tr>
<tr class="separator:acc3ac16f75958b4a14246e944662ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3feadf744ebeb19048ce5b0b85a1678"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae3feadf744ebeb19048ce5b0b85a1678">lens</a></td></tr>
<tr class="memdesc:ae3feadf744ebeb19048ce5b0b85a1678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with both a lensing shear and magnification applied to it.  <a href="#ae3feadf744ebeb19048ce5b0b85a1678">More...</a><br/></td></tr>
<tr class="separator:ae3feadf744ebeb19048ce5b0b85a1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1733c2288686dd72f5389ede87e8aac3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a1733c2288686dd72f5389ede87e8aac3">rotate</a></td></tr>
<tr class="memdesc:a1733c2288686dd72f5389ede87e8aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> <code>theta</code>.  <a href="#a1733c2288686dd72f5389ede87e8aac3">More...</a><br/></td></tr>
<tr class="separator:a1733c2288686dd72f5389ede87e8aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3a8a6ccc44432106e64f1003e3daf6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#afe3a8a6ccc44432106e64f1003e3daf6">transform</a></td></tr>
<tr class="memdesc:afe3a8a6ccc44432106e64f1003e3daf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it.  <a href="#afe3a8a6ccc44432106e64f1003e3daf6">More...</a><br/></td></tr>
<tr class="separator:afe3a8a6ccc44432106e64f1003e3daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a17a4998b3d8ba6e13e9f0779e56f3697">shift</a></td></tr>
<tr class="memdesc:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object shifted by some amount in real space.  <a href="#a17a4998b3d8ba6e13e9f0779e56f3697">More...</a><br/></td></tr>
<tr class="separator:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe6ca9d84fe81543fbc105b897273db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db">drawImage</a></td></tr>
<tr class="memdesc:aafe6ca9d84fe81543fbc105b897273db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an Image of the object.  <a href="#aafe6ca9d84fe81543fbc105b897273db">More...</a><br/></td></tr>
<tr class="separator:aafe6ca9d84fe81543fbc105b897273db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00cbdbb8cdac6d650bae682b5dc2367"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae00cbdbb8cdac6d650bae682b5dc2367">drawKImage</a></td></tr>
<tr class="memdesc:ae00cbdbb8cdac6d650bae682b5dc2367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the k-space Image (both real and imaginary parts) of the object, with bounds optionally set by input Image instances.  <a href="#ae00cbdbb8cdac6d650bae682b5dc2367">More...</a><br/></td></tr>
<tr class="separator:ae00cbdbb8cdac6d650bae682b5dc2367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cddb798d67503569d93c5355485f342"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a2cddb798d67503569d93c5355485f342">__ne__</a></td></tr>
<tr class="separator:a2cddb798d67503569d93c5355485f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a16f3c4d1e56d71468de25594432cbe6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#a16f3c4d1e56d71468de25594432cbe6f">scale</a></td></tr>
<tr class="separator:a16f3c4d1e56d71468de25594432cbe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fab842d9fc3e74f169ca43cea3b386"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_pixel.html#ad4fab842d9fc3e74f169ca43cea3b386">flux</a></td></tr>
<tr class="separator:ad4fab842d9fc3e74f169ca43cea3b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52599607e0e66c8f85a3220791888a3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a52599607e0e66c8f85a3220791888a3b">SBProfile</a></td></tr>
<tr class="separator:a52599607e0e66c8f85a3220791888a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e54bb1d6a0c3619a1cecd8eff5aaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a8c0e54bb1d6a0c3619a1cecd8eff5aaa">noise</a></td></tr>
<tr class="separator:a8c0e54bb1d6a0c3619a1cecd8eff5aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class describing a pixel profile. </p>
<p>This is just a 2D square top-hat function.</p>
<p>This class is typically used to represent a pixel response function. It is used internally by the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> function, but there may be cases where the user would want to use this profile directly.</p>
<h2>Initialization </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The linear scale size of the pixel. Typically given in arcsec. </td></tr>
    <tr><td class="paramname">flux</td><td>The flux (in photons) of the profile. This should almost certainly be left at the default value of 1. [default: 1] </td></tr>
    <tr><td class="paramname">gsparams</td><td>An optional <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> argument. See the docstring for <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> for details. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<h2>Methods </h2>
<p>In addition to the usual <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> methods, <a class="el" href="classgalsim_1_1base_1_1_pixel.html" title="A class describing a pixel profile. ">Pixel</a> has the following access method: </p>
<pre class="fragment">&gt;&gt;&gt; scale = pixel.getScale()</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad3a6c13854c6de2710229aaa3f4ec106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gsparams</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace2781f482d5599469ba51aea46b5b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a182d9f8b408ee4582d170c760c533d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__div__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * (1/other) </p>

</div>
</div>
<a class="anchor" id="ac38606c22888fb021b0eab022af1dc7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a505209aa120683e09f945abed6e25c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.__hash__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa31d94eb1b6367d8034d4cd2c46cd94b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale the flux of the object by the given factor. </p>
<p>obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount.</p>
<p>You can also multiply by an SED, which will create a ChromaticObject where the SED acts like a wavelength-dependent <code>flux_ratio</code>.</p>
<p>obj * sed is equivalent to galsim.Chromatic(obj, sed) </p>

</div>
</div>
<a class="anchor" id="a2cddb798d67503569d93c5355485f342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1354e0f4249428f1f10a52833ac0f9e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a27f25c7faffd8c29a45477abc21459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * other. </p>

</div>
</div>
<a class="anchor" id="a447a14597fd8c77cb49ebec7e12ce916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7cfe7e40fdb14bfcab71133684685e5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf331fe434ce3c71b64ce2745d0b75ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__truediv__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * (1/other) </p>

</div>
</div>
<a class="anchor" id="a3812e25f78dc7a5d6d21cd29298072ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.calculateFWHM </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full-width half-maximum (FWHM) of the object. </p>
<p>If the profile has a fwhm attribute, it will just return that, but in the general case, we draw the profile and estimate the FWHM directly.</p>
<p>As with calculateHLR and calculateMomentRadius, this function optionally takes size and scale values to use for the image drawing. The default is to use the the Nyquist scale for the pixel scale and let drawImage choose a size for the stamp that will enclose at least 99.5% of the flux. These were found to produce results accurate to well below one percent on our internal tests, so it is unlikely that you will want to adjust them for accuracy. However, using a smaller size than default could help speed up the calculation, since the default is usually much larger than is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquistScale()] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid()]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the full-width half-maximum in physical units </dd></dl>

</div>
</div>
<a class="anchor" id="a36d908b3050ba0457c079a343d38e2dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.calculateHLR </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_frac</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the half-light radius of the object. </p>
<p>If the profile has a half_light_radius attribute, it will just return that, but in the general case, we draw the profile and estimate the half-light radius directly.</p>
<p>This function (by default at least) is only accurate to a few percent, typically. Possibly worse depending on the profile being measured. If you care about a high precision estimate of the half-light radius, the accuracy can be improved using the optional parameter scale to change the pixel scale used to draw the profile.</p>
<p>The default scale is half the Nyquist scale, which were found to produce results accurate to a few percent on our internal tests. Using a smaller scale will be more accurate at the expense of speed.</p>
<p>In addition, you can optionally specify the size of the image to draw. The default size is None, which means drawImage will choose a size designed to contain around 99.5% of the flux. This is overkill for this calculation, so choosing a smaller size than this may speed up this calculation somewhat.</p>
<p>Also, while the name of this function refers to the half-light radius, in fact it can also calculate radii that enclose other fractions of the light, according to the parameter <code>flux_frac</code>. E.g. for r90, you would set flux_frac=0.90.</p>
<p>The default scale should usually be acceptable for things like testing that a galaxy has a reasonable resolution, but they should not be trusted for very fine grain discriminations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: 0.5 * self.nyquistScale()] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid()] </td></tr>
    <tr><td class="paramname">flux_frac</td><td>The fraction of light to be enclosed by the returned radius. [default: 0.5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the half-light radius in physical units </dd></dl>

</div>
</div>
<a class="anchor" id="a9740f23217a1e1791862633036f1cd7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.calculateMomentRadius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'det'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an estimate of the radius based on unweighted second moments. </p>
<p>The second moments are defined as:</p>
<p>Q_ij = int( I(x,y) i j dx dy ) / int( I(x,y) dx dy ) where i,j may be either x or y.</p>
<p>If I(x,y) is a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2D Gaussian surface brightness profile. ">Gaussian</a>, then T = Tr(Q) = Qxx + Qyy = 2 sigma^2. Thus, one reasonable choice for a "radius" for an arbitrary profile is sqrt(T/2).</p>
<p>In addition, det(Q) = sigma^4. So another choice for an arbitrary profile is det(Q)^1/4.</p>
<p>This routine can return either of these measures according to the value of the <code>rtype</code> parameter. <code>rtype='trace'</code> will cause it to return sqrt(T/2). <code>rtype='det'</code> will cause it to return det(Q)^1/4. And <code>rtype='both'</code> will return a tuple with both values.</p>
<p>Note that for the special case of a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2D Gaussian surface brightness profile. ">Gaussian</a> profile, no calculation is necessary, and the <code>sigma</code> attribute will be used in both cases. In the limit as scale-&gt;0, this function will return the same value, but because finite pixels are drawn, the results will not be precisely equal for real use cases. The approximation being made is that the integral of I(x,y) i j dx dy over each pixel can be approximated as int(I(x,y) dx dy) * i_center * j_center.</p>
<p>This function (by default at least) is only accurate to a few percent, typically. Possibly worse depending on the profile being measured. If you care about a high precision estimate of the radius, the accuracy can be improved using the optional parameters size and scale to change the size and pixel scale used to draw the profile.</p>
<p>The default is to use the the Nyquist scale for the pixel scale and let drawImage choose a size for the stamp that will enclose at least 99.5% of the flux. These were found to produce results accurate to a few percent on our internal tests. Using a smaller scale and larger size will be more accurate at the expense of speed.</p>
<p>The default parameters should usually be acceptable for things like testing that a galaxy has a reasonable resolution, but they should not be trusted for very fine grain discriminations. For a more accurate estimate, see <a class="el" href="namespacegalsim_1_1hsm.html#a609965656c1fb90e664a6439312ac1fc" title="Measure adaptive moments of an object. ">galsim.hsm.FindAdaptiveMom</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquistScale()] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid()] </td></tr>
    <tr><td class="paramname">rtype</td><td>There are three options for this parameter:<ul>
<li>'trace' means return sqrt(T/2)</li>
<li>'det' means return det(Q)^1/4</li>
<li>'both' means return both: (sqrt(T/2), det(Q)^1/4) [default: 'det']</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the radius in physical units (or both estimates if rtype == 'both') </dd></dl>

</div>
</div>
<a class="anchor" id="a08a0bb72927fce3c765a9580de656d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>. </p>

</div>
</div>
<a class="anchor" id="aa0b398d4b0fca70211e4a73f81ea7e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of an object. </p>
<p>NB. This is a shallow copy, which is normally fine. However, if the object has a noise attribute, then the copy will use the same rng, so calls to things like noise.whitenImage from the two copies would produce different realizations of the noise. If you want these to be precisely identical, then copy.deepcopy will make an exact duplicate, which will have identical noise realizations for that kind of application. </p>

</div>
</div>
<a class="anchor" id="a0e80b6924c48e9708dd9e475f3b48b5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.dilate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for versions that preserve surface brightness, and thus changes the flux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The linear rescaling factor to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dilated object. </dd></dl>

</div>
</div>
<a class="anchor" id="aafe6ca9d84fe81543fbc105b897273db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.drawImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_true_center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an Image of the object. </p>
<p>The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> method is used to draw an Image of the current object using one of several possible rendering methods (see below). It can create a new Image or can draw onto an existing one if provided by the <code>image</code> parameter. If the <code>image</code> is given, you can also optionally add to the given Image if <code>add_to_image = True</code>, but the default is to replace the current contents with new values.</p>
<p>Note that if you provide an <code>image</code> parameter, it is the image onto which the profile will be drawn. The provided image <em>will be modified</em>. A reference to the same image is also returned to provide a parallel return behavior to when <code>image</code> is <code>None</code> (described above).</p>
<p>This option is useful in practice because you may want to construct the image first and then draw onto it, perhaps multiple times. For example, you might be drawing onto a subimage of a larger image. Or you may want to draw different components of a complex profile separately. In this case, the returned value is typically ignored. For example: </p>
<pre class="fragment">    &gt;&gt;&gt; im1 = bulge.drawImage()
    &gt;&gt;&gt; im2 = disk.drawImage(image=im1, add_to_image=True)
    &gt;&gt;&gt; assert im1 is im2

    &gt;&gt;&gt; full_image = galsim.Image(2048, 2048, scale=pixel_scale)
    &gt;&gt;&gt; b = galsim.BoundsI(x-32, x+32, y-32, y+32)
    &gt;&gt;&gt; stamp = obj.drawImage(image = full_image[b])
    &gt;&gt;&gt; assert (stamp.array == full_image[b].array).all()
</pre><p>If <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> will be creating the image from scratch for you, then there are several ways to control the size of the new image. If the <code>nx</code> and <code>ny</code> keywords are present, then an image with these numbers of pixels on a side will be created. Similarly, if the <code>bounds</code> keyword is present, then an image with the specified bounds will be created. Note that it is an error to provide an existing Image when also specifying <code>nx</code>, <code>ny</code>, or <code>bounds</code>. In the absence of <code>nx</code>, <code>ny</code>, and <code>bounds</code>, drawImage will decide a good size to use based on the size of the object being drawn. Basically, it will try to use an area large enough to include at least 99.5% of the flux. (Note: the value 0.995 is really <code>1 - folding_threshold</code>. You can change the value of <code>folding_threshold</code> for any object via <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a>. See <code>help(GSParams)</code> for more details.) You can set the pixel scale of the constructed image with the <code>scale</code> parameter, or set a WCS function with <code>wcs</code>. If you do not provide either <code>scale</code> or <code>wcs</code>, then <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> will default to using the Nyquist scale for the current object. You can also set the data type used in the new Image with the <code>dtype</code> parameter that has the same options as for the Image constructor.</p>
<p>There are several different possible methods <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> can use for rendering the image. This is set by the <code>method</code> parameter. The options are: </p>
<pre class="fragment">'auto'      This is the default, which will normally be equivalent to 'fft'.  However,
            if the object being rendered is simple (no convolution) and has hard edges
            (e.g. a Box or a truncated Moffat or Sersic), then it will switch to
            'real_space', since that is often both faster and more accurate in these
            cases (due to ringing in Fourier space).

'fft'       The integration of the light within each pixel is mathematically equivalent
            to convolving by the pixel profile (a Pixel object) and sampling the result
            at the centers of the pixels.  This method will do that convolution using
            a discrete Fourier transform.  Furthermore, if the object (or any component
            of it) has been transformed via shear(), dilate(), etc., then these
            transformations are done in Fourier space as well.

'real_space'  This uses direct integrals (using the Gauss-Kronrod-Patterson algorithm)
            in real space for the integration over the pixel response.  It is usually
            slower than the 'fft' method, but if the profile has hard edges that cause
            ringing in Fourier space, it can be faster and/or more accurate.  If you
            use 'real_space' with something that is already a Convolution, then this
            will revert to 'fft', since the double convolution that is required to also
            handle the pixel response is far too slow to be practical using real-space
            integrals.

'phot'      This uses a technique called photon shooting to render the image.
            Essentially, the object profile is taken as a probability distribution
            from which a finite number of photons are "shot" onto the image.  Each
            photon's flux gets added to whichever pixel the photon hits.  This process
            automatically accounts for the integration of the light over the pixel
            area, since all photons that hit any part of the pixel are counted.
            Convolutions and transformations are simple geometric processes in this
            framework.  However, there are two caveats with this method: (1) the
            resulting image will have Poisson noise from the finite number of photons,
            and (2) it is not available for all object types (notably anything that
            includes a Deconvolution).

'no_pixel'  Instead of integrating over the pixels, this method will sample the profile
            at the centers of the pixels and multiply by the pixel area.  If there is
            a convolution involved, the choice of whether this will use an FFT or
            real-space calculation is governed by the `real_space` parameter of the
            Convolution class.  This method is the appropriate choice if you are using
            a PSF that already includes a convolution by the pixel response.  For
            example, if you are using a PSF from an observed image of a star, then it
            has already been convolved by the pixel, so you would not want to do so
            again.  Note: The multiplication by the pixel area gets the flux
            normalization right for the above use case.  cf. `method = 'sb'`.

'sb'        This is a lot like 'no_pixel', except that the image values will simply be
            the sampled object profile's surface brightness, not multiplied by the
            pixel area.  This does not correspond to any real observing scenario, but
            it could be useful if you want to view the surface brightness profile of an
            object directly, without including the pixel integration.
</pre><p>Normally, the flux of the object should be equal to the sum of all the pixel values in the image, less some small amount of flux that may fall off the edge of the image (assuming you don't use <code>method='sb'</code>). However, you may optionally set a <code>gain</code> value, which converts between photons and ADU (so-called analog-to-digital units), the units of the pixel values in real images. Normally, the gain of a CCD is in electrons/ADU, but in GalSim, we fold the quantum efficiency into the gain as well, so the units are photons/ADU. The flux of the object is then taken to be in photons, and the <code>gain</code> converts this to ADU.</p>
<p>The 'phot' method has a few extra parameters that adjust how it functions. The total number of photons to shoot is normally calculated from the object's flux. This flux is taken to be given in photons, so for most simple profiles, this will equal the number of photons shot. (See the discussion in Rowe et al, 2014, for why this might be modified for InterpolatedImage and related profiles.) However, you can manually set a different number of photons with <code>n_photons</code>. You can also set <code>max_extra_noise</code> to tell <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> to use fewer photons than normal (and so is faster) such that no more than that much extra noise is added to any pixel. This is particularly useful if you will be subsequently adding sky noise, and you can thus tolerate more noise than the normal number of photons would give you, since using fewer photons is of course faster. Finally, the default behavior is to have the total flux vary as a Poisson random variate, which is normally appropriate with photon shooting. But you can turn this off with <code>poisson_flux=False</code>. It also defaults to False if you set an explicit value for <code>n_photons</code>.</p>
<p>The object will by default be drawn with its nominal center at the center location of the image. There is thus a qualitative difference in the appearance of the rendered profile when drawn on even- and odd-sized images. For a profile with a maximum at (0,0), this maximum will fall in the central pixel of an odd-sized image, but in the corner of the four central pixels of an even-sized image. There are two parameters that can affect this behavior. If you want the nominal center to always fall at the center of a pixel, you can use <code>use_true_center=False</code>. This will put the object's center at the position <code>image.center()</code> which is an integer pixel value, and is not the true center of an even-sized image. You can also arbitrarily offset the profile from the image center with the <code>offset</code> parameter to handle any sub-pixel dithering you want.</p>
<p>On return, the image will have an attribute <code>added_flux</code>, which will be set to be the total flux added to the image. This may be useful as a sanity check that you have provided a large enough image to catch most of the flux. For example: </p>
<pre class="fragment">&gt;&gt;&gt; obj.drawImage(image)
&gt;&gt;&gt; assert image.added_flux &gt; 0.99 * obj.getFlux()
</pre><p>The appropriate threshold will depend on your particular application, including what kind of profile the object has, how big your image is relative to the size of your object, whether you are keeping <code>poisson_flux=True</code>, etc.</p>
<p>Given the periodicity implicit in the use of FFTs, there can occasionally be artifacts due to wrapping at the edges, particularly for objects that are quite extended (e.g., due to the nature of the radial profile). Use of the keyword parameter <code>wmult &gt; 1</code> can be used to reduce the size of these artifacts (by making larger FFT images), at the expense of the calculations taking longer and using more memory. Alternatively, the objects that go into the image can be created with a <code>gsparams</code> keyword that has a lower-than-default value for <code>folding_threshold</code>; see <code>help(<a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams</a>)</code> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the image on which to draw the profile. If <code>image</code> is None, then an automatically-sized Image will be created. If <code>image</code> is given, but its bounds are undefined (e.g. if it was constructed with <code>image = galsim.Image()</code>), then it will be resized appropriately based on the profile's size [default: None]. </td></tr>
    <tr><td class="paramname">nx</td><td>If provided and <code>image</code> is None, use to set the x-direction size of the image. Must be accompanied by <code>ny</code>. </td></tr>
    <tr><td class="paramname">ny</td><td>If provided and <code>image</code> is None, use to set the y-direction size of the image. Must be accompanied by <code>nx</code>. </td></tr>
    <tr><td class="paramname">bounds</td><td>If provided and <code>image</code> is None, use to set the bounds of the image. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the image. If <code>scale</code> is None and <code>image</code> is given, then take the provided image's pixel scale. If <code>scale</code> is None and <code>image</code> is None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>image</code>), then use the Nyquist scale. If <code>scale &gt; 0</code> and <code>image</code> is given, then override <code>image.scale</code> with the value given as a keyword. [default: None] </td></tr>
    <tr><td class="paramname">wcs</td><td>If provided, use this as the wcs for the image (possibly overriding any existing <code>image.wcs</code>). At most one of <code>scale</code> or <code>wcs</code> may be provided. [default: None] </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type to use for an automatically constructed image. Only valid if <code>image</code> is None. [default: None, which means to use numpy.float32] </td></tr>
    <tr><td class="paramname">method</td><td>Which method to use for rendering the image. See discussion above for the various options and what they do. [default: 'auto'] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1] </td></tr>
    <tr><td class="paramname">wmult</td><td>A multiplicative factor by which to enlarge (in each direction) the default automatically calculated FFT grid size used for any intermediate calculations in Fourier space. The size of the intermediate images is normally automatically chosen to reach some preset accuracy targets [cf. <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a>]; however, if you see strange artifacts in the image, you might try using <code>wmult &gt; 1</code>. This will take longer of course, but it will produce more accurate images, since they will have less "folding" in Fourier space. If the image size is not specified, then the output real-space image will be enlarged by a factor of <code>wmult</code>. If the image size is specified by the user, rather than automatically-sized, use of <code>wmult&gt;1</code> will still affect the size of the images used for the Fourier-space calculations and hence can reduce image artifacts, even though the image that is returned will be the requested size. [default: 1] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. Note: This requires that <code>image</code> be provided and that it have defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">use_true_center</td><td>Normally, the profile is drawn to be centered at the true center of the image (using the function image.bounds.trueCenter()). If you would rather use the integer center (given by image.bounds.center()), set this to <code>False</code>. [default: True] </td></tr>
    <tr><td class="paramname">offset</td><td>The location in pixel coordinates at which to center the profile being drawn relative to the center of the image (either the true center if <code>use_true_center=True</code> or nominal center if <code>use_true_center=False</code>). [default: None] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use for photon shooting. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel when photon shooting. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, then you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. [default: 0.] </td></tr>
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples when photon shooting. [default: True, unless <code>n_photons</code> is given, in which case the default is False] </td></tr>
    <tr><td class="paramname">setup_only</td><td>Don't actually draw anything on the image. Just make sure the image is set up correctly. This is used internally by GalSim, but there may be cases where the user will want the same functionality. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the drawn Image. </dd></dl>

</div>
</div>
<a class="anchor" id="ae00cbdbb8cdac6d650bae682b5dc2367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.drawKImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>re</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dk</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the k-space Image (both real and imaginary parts) of the object, with bounds optionally set by input Image instances. </p>
<p>Normalization is always such that re(0,0) = flux. Unlike the real-space <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> function, the (0,0) point will always be one of the actual pixel values. For even-sized images, it will be 1/2 pixel above and to the right of the true center of the image.</p>
<p>Another difference from <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafe6ca9d84fe81543fbc105b897273db" title="Draws an Image of the object. ">drawImage()</a> is that a wcs other than a simple pixel scale is not allowed. There is no <code>wcs</code> parameter here, and if the images have a non-trivial wcs (and you don't override it with the <code>scale</code> parameter), a TypeError will be raised.</p>
<p>Also, there is no convolution by a pixel. This is just a direct image of the Fourier transform of the surface brightness profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>If provided, this will be the real part of the k-space image. If <code>re</code> and <code>im</code> are None, then automatically-sized images will be created. If they are given, but their bounds are undefined, then they will be resized appropriately based on the profile's size. [default: None] </td></tr>
    <tr><td class="paramname">im</td><td>If provided, this will be the imaginary part of the k-space image. A provided <code>im</code> must match the size and scale of <code>re</code>. If <code>im</code> is None, then <code>re</code> must also be None. [default: None] </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale, dk, for the images. If <code>scale</code> is None and <code>re</code> and <code>im</code> are given, then take the provided images' pixel scale (which must be equal). If <code>scale</code> is None and <code>re</code> and <code>im</code> are None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>re</code>, <code>im</code>), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type to use for automatically constructed images. Only valid if <code>re</code> and <code>im</code> are None. [default: None, which means to use numpy.float32] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1.] </td></tr>
    <tr><td class="paramname">wmult</td><td>A multiplicative factor by which to enlarge (in each direction) the size of the image, if you are having <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae00cbdbb8cdac6d650bae682b5dc2367" title="Draws the k-space Image (both real and imaginary parts) of the object, with bounds optionally set by ...">drawKImage()</a> automatically construct the images for you. [default: 1] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. Note: This requires that <code>re</code> and <code>im</code> be provided and that they have defined bounds. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple of Image instances, <code>(re, im)</code> (created if necessary) </dd></dl>

</div>
</div>
<a class="anchor" id="abb2f53aa19bbfcc16f980072ef07fc9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.evaluateAtWavelength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return profile at a given wavelength. </p>
<p>For <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances, this is just <code>self</code>. This allows <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances to be duck-typed as ChromaticObject instances. </p>

</div>
</div>
<a class="anchor" id="a582e45c3a235ce1be2f58bfb2070ef15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>This doesn't correspond to either of the normal operations one would typically want to do to a galaxy. The functions <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> are the more typical usage. But this function is conceptually simple. It rescales the linear dimension of the profile, while preserving surface brightness. As a result, the flux will necessarily change as well.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for a version that applies a scale factor to the area while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The factor by which to scale the linear dimension of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expanded object. </dd></dl>

</div>
</div>
<a class="anchor" id="a38e31527de68d7072651399aeda5209d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a662d8ce421ecd90080bdcaaf6890aed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.getFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the flux of the object. </p>

</div>
</div>
<a class="anchor" id="aa243ddb524351768f33f6dbd3c594917"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.getGSParams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> for the object. </p>

</div>
</div>
<a class="anchor" id="a5e462952240641aaf2faf4bdf0e13020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.getScale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pixel scale. </p>

</div>
</div>
<a class="anchor" id="a5c07d68ffe9123beae4d7217f7f57a18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.gsparams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f480514538e924d29af411563384a6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.hasHardEdges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain. </p>

</div>
</div>
<a class="anchor" id="ad883087f48bb56d90612d940dd60a7ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAnalyticK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a671c7778e707ab11a75a1f5877aa76ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAnalyticX </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a109bc7c81be65f8fc5d5ec32e6d0c0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAxisymmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if axially symmetric: affects efficiency of evaluation. </p>

</div>
</div>
<a class="anchor" id="ac8652894487904b797d7752651b54507"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.kValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in k space. </p>
<p>This function returns the amplitude of the fourier transform of the surface brightness profile at a given position in k space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as kx,ky (either as a tuple or as two arguments).</p>
<p>Techinically, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac8652894487904b797d7752651b54507" title="Returns the value of the object at a chosen 2D position in k space. ">kValue()</a> is available if and only if the given obj has <code>obj.isAnalyticK() == True</code>, but this is the case for all GSObjects currently, so that should never be an issue (unlike for <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in k space at which you want the fourier amplitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amplitude of the fourier transform at that position. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3feadf744ebeb19048ce5b0b85a1678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.lens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with both a lensing shear and magnification applied to it. </p>
<p>This <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> method applies a lensing (reduced) shear and magnification. The shear must be specified using the g1, g2 definition of shear (see Shear documentation for more details). This is the same definition as the outputs of the PowerSpectrum and NFWHalo classes, which compute shears according to some lensing power spectrum or lensing by an NFW dark matter halo. The magnification determines the rescaling factor for the object area and flux, preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">g2</td><td>Second component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">mu</td><td>Lensing magnification to apply to the object. This is the factor by which the solid angle subtended by the object is magnified, preserving surface brightness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lensed object. </dd></dl>

</div>
</div>
<a class="anchor" id="aac64da7ce1c4165ba048300fede29943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.magnify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by <code>mu</code> at fixed surface brightness. </p>
<p>This process applies a lensing magnification mu, which scales the linear dimensions of the image by the factor sqrt(mu), i.e., <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * sqrt(mu)</code> while increasing the flux by a factor of mu. Thus, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> preserves surface brightness.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> for a version that applies a linear scale factor while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>The lensing magnification to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the magnified object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ab9d51f34703ced5be1592e112605ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.maxK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value of k beyond which aliasing can be neglected. </p>

</div>
</div>
<a class="anchor" id="ab95676589d95590c2ce593adcf4f4198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.nyquistScale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Image pixel spacing that does not alias maxK. </p>

</div>
</div>
<a class="anchor" id="a1733c2288686dd72f5389ede87e8aac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.rotate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> <code>theta</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Rotation angle (<a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> object, +ve anticlockwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated object. </dd></dl>

</div>
</div>
<a class="anchor" id="a982cc6a557574368a7a08b8d00c4bbb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Pixel.scale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aceaea743ee14bfc5608142603867b240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.SED </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c372339cdb51586c20e281dfae3a7c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.separable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acc3ac16f75958b4a14246e944662ce3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with an area-preserving shear applied to it. </p>
<p>The arguments may be either a Shear instance or arguments to be used to initialize one.</p>
<p>For more details about the allowed keyword arguments, see the documentation for Shear (for doxygen documentation, see <a class="el" href="classgalsim_1_1shear_1_1_shear.html" title="A class to represent shears in a variety of ways. ">galsim.shear.Shear</a>).</p>
<p>The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> method precisely preserves the area. To include a lensing distortion with the appropriate change in area, either use <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> with <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a>, or use <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae3feadf744ebeb19048ce5b0b85a1678" title="Create a version of the current object with both a lensing shear and magnification applied to it...">lens()</a>, which combines both operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shear</td><td>The Shear to be applied. Or, as described above, you may instead supply parameters do construct a shear directly. eg. <code>obj.shear(g1=g1,g2=g2)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sheared object. </dd></dl>

</div>
</div>
<a class="anchor" id="a17a4998b3d8ba6e13e9f0779e56f3697"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object shifted by some amount in real space. </p>
<p>After this call, the caller's type will be a <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. This means that if the caller was a derived type that had extra methods beyond those defined in <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> (e.g. getSigma() for a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2D Gaussian surface brightness profile. ">Gaussian</a>), then these methods are no longer available.</p>
<p>Note: in addition to the dx,dy parameter names, you may also supply dx,dy as a tuple, or as a PositionD or PositionI object.</p>
<p>The shift coordinates here are sky coordinates. GSObjects are always defined in sky coordinates and only later (when they are drawn) is the connection to pixel coordinates established (via a pixel_scale or WCS). So a shift of dx moves the object horizontally in the sky (e.g. west in the local tangent plane of the observation), and dy moves the object vertically (north in the local tangent plane).</p>
<p>The units are typically arcsec, but we don't enforce that anywhere. The units here just need to be consistent with the units used for any size values used by the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. The connection of these units to the eventual image pixels is defined by either the <code>pixel_scale</code> or the <code>wcs</code> parameter of <code>drawImage</code>.</p>
<p>Note: if you want to shift the object by a set number (or fraction) of pixels in the drawn image, you probably want to use the <code>offset</code> parameter of <code>drawImage</code> rather than this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Horizontal shift to apply. </td></tr>
    <tr><td class="paramname">dy</td><td>Vertical shift to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b5da3e499f3c00def5f7f54cab532f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.stepK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sampling in k space necessary to avoid folding of image in x space. </p>

</div>
</div>
<a class="anchor" id="afe3a8a6ccc44432106e64f1003e3daf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it. </p>
<p>This applies a Jacobian matrix to the coordinate system in which this object is defined. It changes a profile defined in terms of (x,y) to one defined in terms of (u,v) where: </p>
<pre class="fragment">u = dudx x + dudy y
v = dvdx x + dvdy y
</pre><p>That is, an arbitrary affine transform, but without the translation (which is easily effected via the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a17a4998b3d8ba6e13e9f0779e56f3697" title="Create a version of the current object shifted by some amount in real space. ">shift()</a> method).</p>
<p>Note that this function is similar to expand in that it preserves surface brightness, not flux. If you want to preserve flux, you should also do </p>
<pre class="fragment">&gt;&gt;&gt; prof *= 1./abs(dudx*dvdy - dudy*dvdx)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dudx</td><td>du/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dudy</td><td>du/dy, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdx</td><td>dv/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdy</td><td>dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transformed object </dd></dl>

</div>
</div>
<a class="anchor" id="ac49c7fc355ce10a3fc041f27c1eb334f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.wave_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f12b6158381ca5ef6da8e94f701f3e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.withFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with a different flux. </p>
<p>This function is equivalent to <code>obj.withScaledFlux(flux / obj.getFlux())</code>.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location rescaled such that the total flux will be the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux</td><td>The new flux for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux </dd></dl>

</div>
</div>
<a class="anchor" id="a21a5b330e1c7565a2bb56258127d6149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.withScaledFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>. </p>
<p>This function is equivalent to <code>obj.withFlux(flux_ratio * obj.getFlux())</code>. However, this function is the more efficient one, since it doesn't actually require the call to <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8" title="Returns the flux of the object. ">getFlux()</a>. Indeed, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3f12b6158381ca5ef6da8e94f701f3e5" title="Create a version of the current object with a different flux. ">withFlux()</a> is implemented in terms of this one and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8" title="Returns the flux of the object. ">getFlux()</a>.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount.</p>
<p>An equivalent, and usually simpler, way to effect this scaling is </p>
<pre class="fragment">obj = obj * flux_ratio
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux_ratio</td><td>The ratio by which to rescale the flux of the object when creating a new one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a30355af05f88c36f078099b6bb792e1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.xValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in real space. </p>
<p>This function returns the surface brightness of the object at a particular position in real space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as x,y (either as a tuple or as two arguments).</p>
<p>The object surface brightness profiles are typically defined in world coordinates, so the position here should be in world coordinates as well.</p>
<p>Not all <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> classes can use this method. Classes like Convolution that require a Discrete Fourier Transform to determine the real space values will not do so for a single position. Instead a RuntimeError will be raised. The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method is available if and only if <code>obj.isAnalyticX() == True</code>.</p>
<p>Users who wish to use the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for an object that is the convolution of other profiles can do so by drawing the convolved profile into an image, using the image to initialize a new InterpolatedImage, and then using the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for that new object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position at which you want the surface brightness of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the surface brightness at that position. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad4fab842d9fc3e74f169ca43cea3b386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.Pixel.flux</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c0e54bb1d6a0c3619a1cecd8eff5aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.noise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52599607e0e66c8f85a3220791888a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.SBProfile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16f3c4d1e56d71468de25594432cbe6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.Pixel.scale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="base_8py.html">base.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
