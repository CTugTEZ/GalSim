<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.lensing_ps.PowerSpectrum Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1lensing__ps.html">lensing_ps</a></li><li class="navelem"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html">PowerSpectrum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgalsim_1_1lensing__ps_1_1_power_spectrum-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim.lensing_ps.PowerSpectrum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to represent a lensing shear field according to some power spectrum P(k).  
 <a href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for galsim.lensing_ps.PowerSpectrum:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1lensing__ps_1_1_power_spectrum.png" usemap="#galsim.lensing_ps.PowerSpectrum_map" alt=""/>
  <map id="galsim.lensing_ps.PowerSpectrum_map" name="galsim.lensing_ps.PowerSpectrum_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0bf7a88aee4e7f903a5fe8d19ea6cdf0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0bf7a88aee4e7f903a5fe8d19ea6cdf0">__init__</a></td></tr>
<tr class="separator:a0bf7a88aee4e7f903a5fe8d19ea6cdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30baffd37afb9a0fc94c0b3ed468ea2f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a30baffd37afb9a0fc94c0b3ed468ea2f">__repr__</a></td></tr>
<tr class="separator:a30baffd37afb9a0fc94c0b3ed468ea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519ae191cdda24e7c8ddab47bff3eb17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a519ae191cdda24e7c8ddab47bff3eb17">__str__</a></td></tr>
<tr class="separator:a519ae191cdda24e7c8ddab47bff3eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfb65787431d770d9e1e9e842e61a8b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afbfb65787431d770d9e1e9e842e61a8b">__eq__</a></td></tr>
<tr class="separator:afbfb65787431d770d9e1e9e842e61a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c5a3ca3270ac6f63b3cf89e0e2ed6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a4d7c5a3ca3270ac6f63b3cf89e0e2ed6">__ne__</a></td></tr>
<tr class="separator:a4d7c5a3ca3270ac6f63b3cf89e0e2ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f22414155c4cdcc6f32ee9079adcec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#ae1f22414155c4cdcc6f32ee9079adcec">__hash__</a></td></tr>
<tr class="separator:ae1f22414155c4cdcc6f32ee9079adcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069">buildGrid</a></td></tr>
<tr class="memdesc:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a realization of the current power spectrum on the specified grid.  <a href="#a2009ebd0aaab64683fcd60ba5b0d8069">More...</a><br/></td></tr>
<tr class="separator:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dde5ca70773d8f57eecb1f5bdb642c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a96dde5ca70773d8f57eecb1f5bdb642c">nRandCallsForBuildGrid</a></td></tr>
<tr class="memdesc:a96dde5ca70773d8f57eecb1f5bdb642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of times the rng() was called the last time buildGrid was called.  <a href="#a96dde5ca70773d8f57eecb1f5bdb642c">More...</a><br/></td></tr>
<tr class="separator:a96dde5ca70773d8f57eecb1f5bdb642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad312cc52f9a3b4ea51221b16b01ffbe8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#ad312cc52f9a3b4ea51221b16b01ffbe8">subsampleGrid</a></td></tr>
<tr class="memdesc:ad312cc52f9a3b4ea51221b16b01ffbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to use a regular subset of the grid points without a completely new call to <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a>.  <a href="#ad312cc52f9a3b4ea51221b16b01ffbe8">More...</a><br/></td></tr>
<tr class="separator:ad312cc52f9a3b4ea51221b16b01ffbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d192ea3aa594fbf46c044c5292bfcae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8d192ea3aa594fbf46c044c5292bfcae">calculateXi</a></td></tr>
<tr class="memdesc:a8d192ea3aa594fbf46c044c5292bfcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate shear correlation functions for the current power spectrum on the specified grid.  <a href="#a8d192ea3aa594fbf46c044c5292bfcae">More...</a><br/></td></tr>
<tr class="separator:a8d192ea3aa594fbf46c044c5292bfcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1354152d2b348a2fbe33bd8367f041"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041">getShear</a></td></tr>
<tr class="memdesc:a0b1354152d2b348a2fbe33bd8367f041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position).  <a href="#a0b1354152d2b348a2fbe33bd8367f041">More...</a><br/></td></tr>
<tr class="separator:a0b1354152d2b348a2fbe33bd8367f041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7ada810e77c7b4d1d6e24272a54661"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8a7ada810e77c7b4d1d6e24272a54661">getConvergence</a></td></tr>
<tr class="memdesc:a8a7ada810e77c7b4d1d6e24272a54661"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the convergence values for a given list of input positions (or just a single position).  <a href="#a8a7ada810e77c7b4d1d6e24272a54661">More...</a><br/></td></tr>
<tr class="separator:a8a7ada810e77c7b4d1d6e24272a54661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97802ce5dd46c3741cb547a9886a5953"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a97802ce5dd46c3741cb547a9886a5953">getMagnification</a></td></tr>
<tr class="memdesc:a97802ce5dd46c3741cb547a9886a5953"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the lensing magnification (mu) values for a given list of input positions (or just a single position).  <a href="#a97802ce5dd46c3741cb547a9886a5953">More...</a><br/></td></tr>
<tr class="separator:a97802ce5dd46c3741cb547a9886a5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afdd47f97e7402ca28cffc3e6dec8fe27">getLensing</a></td></tr>
<tr class="memdesc:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the lensing observable quantities (reduced shears g1 and g2, and magnification mu) for a given list of input positions (or just a single position).  <a href="#afdd47f97e7402ca28cffc3e6dec8fe27">More...</a><br/></td></tr>
<tr class="separator:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0ade197b0cbf8fb086299ffa00dac880"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0ade197b0cbf8fb086299ffa00dac880">e_power_function</a></td></tr>
<tr class="separator:a0ade197b0cbf8fb086299ffa00dac880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1680823e5f523dbd6bd29b14a7a8f75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#aa1680823e5f523dbd6bd29b14a7a8f75">b_power_function</a></td></tr>
<tr class="separator:aa1680823e5f523dbd6bd29b14a7a8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92406265cb8e981948c8008c5f1b56af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a92406265cb8e981948c8008c5f1b56af">delta2</a></td></tr>
<tr class="separator:a92406265cb8e981948c8008c5f1b56af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42cab4637dbee68b9b118f266a7bfda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#af42cab4637dbee68b9b118f266a7bfda">units</a></td></tr>
<tr class="separator:af42cab4637dbee68b9b118f266a7bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a214736f544af923f42a17ca5fb1195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a9a214736f544af923f42a17ca5fb1195">scale</a></td></tr>
<tr class="separator:a9a214736f544af923f42a17ca5fb1195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3cac5d382324aba8021271cc948647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8f3cac5d382324aba8021271cc948647">grid_spacing</a></td></tr>
<tr class="separator:a8f3cac5d382324aba8021271cc948647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c78817f9b04e27c7c292b2505bdb7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#ad1c78817f9b04e27c7c292b2505bdb7e">center</a></td></tr>
<tr class="separator:ad1c78817f9b04e27c7c292b2505bdb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424bc6120a3d57678928a7594599e33c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a424bc6120a3d57678928a7594599e33c">adjust_center</a></td></tr>
<tr class="separator:a424bc6120a3d57678928a7594599e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931e6f1a8d4950ffd770fe76d5789ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0931e6f1a8d4950ffd770fe76d5789ca">bounds</a></td></tr>
<tr class="separator:a0931e6f1a8d4950ffd770fe76d5789ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7700448eb709d4abc8f4fc0575fe22d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a7700448eb709d4abc8f4fc0575fe22d6">interpolant</a></td></tr>
<tr class="separator:a7700448eb709d4abc8f4fc0575fe22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d883a1d05717714b99b13d71b010b7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a1d883a1d05717714b99b13d71b010b7e">ngrid_tot</a></td></tr>
<tr class="separator:a1d883a1d05717714b99b13d71b010b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa33a055585d247753d7b4270b69fb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a5aa33a055585d247753d7b4270b69fb6">pixel_size</a></td></tr>
<tr class="separator:a5aa33a055585d247753d7b4270b69fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad4165ff17f51b67bb11c170631a29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8bad4165ff17f51b67bb11c170631a29">grid_kappa</a></td></tr>
<tr class="separator:a8bad4165ff17f51b67bb11c170631a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d639842746d63c080f60c26b42276b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#af5d639842746d63c080f60c26b42276b">grid_g1</a></td></tr>
<tr class="separator:af5d639842746d63c080f60c26b42276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932204e8e0d4d1c0874af50d65f1df3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a932204e8e0d4d1c0874af50d65f1df3f">grid_g2</a></td></tr>
<tr class="separator:a932204e8e0d4d1c0874af50d65f1df3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746956592b3f704836aff1fce0edbfcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a746956592b3f704836aff1fce0edbfcd">im_g1</a></td></tr>
<tr class="separator:a746956592b3f704836aff1fce0edbfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1d0edc315b8bf523bd1146d1227aa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#abe1d0edc315b8bf523bd1146d1227aa5">im_g2</a></td></tr>
<tr class="separator:abe1d0edc315b8bf523bd1146d1227aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348c91e43ddb19bde34b944426f6ca83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a348c91e43ddb19bde34b944426f6ca83">im_kappa</a></td></tr>
<tr class="separator:a348c91e43ddb19bde34b944426f6ca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to represent a lensing shear field according to some power spectrum P(k). </p>
<h2>General considerations </h2>
<p>A <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> represents some (flat-sky) shear power spectrum, either for gridded points or at arbitary positions. This class is originally initialized with a power spectrum from which we would like to generate g1 and g2 (and, optionally, convergence kappa) values. It generates shears on a grid, and if necessary, when <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> (or another <code>get</code> method) is called, it will interpolate to the requested positions. For detail on how these processes are carried out, please see the document in the GalSim repository, <code>devel/modules/lensing_engine.pdf</code>.</p>
<p>This class generates the shears according to the input power spectrum using a DFT approach, which means that we implicitly assume our discrete representation of P(k) on a grid is one complete cell in an infinite periodic series. We are making assumptions about what P(k) is doing outside of our minimum and maximum k range, and those must be kept in mind when comparing with theoretical expectations. Specifically, since the power spectrum is realized on only a finite grid it has been been effectively bandpass filtered between a minimum and maximum k value in each of the k1, k2 directions. See the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> method for more information.</p>
<p>As a result, the shear generation currently does not include sample variance due to coverage of a finite patch. We explicitly enforce <code>P(k=0)=0</code>, which is true for the full sky in a reasonable cosmological model, but it ignores the fact that our little patch of sky might reasonably live in some special region with respect to shear correlations. Our <code>P(k=0)=0</code> is essentially setting the integrated power below our minimum k value to zero. The implications of the discrete representation, and the <code>P(k=0)=0</code> choice, are discussed in more detail in <code>devel/modules/lensing_engine.pdf</code>.</p>
<p>The effective shear correlation function for the gridded points will be modified both because of the DFT approach to representing shears according to a power spectrum, and because of the power cutoff below and above the minimum k values. The latter effect can be particularly important on large scales, so the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> method has some keywords that can be used to reduce the impact of the minimum k set by the grid extent. The <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8d192ea3aa594fbf46c044c5292bfcae" title="Calculate shear correlation functions for the current power spectrum on the specified grid...">calculateXi()</a> method can be used to calculate the expected shear correlation functions given the minimum and maximum k for some grid (but ignoring the discrete vs. continuous Fourier transform effects), for comparison with some ideal theoretical correlation function given an infinite k range.</p>
<p>When interpolating the shears to non-gridded points, the shear correlation function and power spectrum are modified; see the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> and other <code>get</code> method docstrings for more details.</p>
<h2>The power spectra to be used </h2>
<p>When creating a <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> instance, you must specify at least one of the E or B mode power spectra, which is normally given as a function P(k). The typical thing is to just use a lambda function in Python (i.e., a function that is not associated with a name); for example, to define P(k)=k^2, one would use <code>lambda k : k**2</code>. But the power spectra can also be more complicated user-defined functions that take a single argument <code>k</code> and return the power at that <code>k</code> value, or they can be instances of the LookupTable class for power spectra that are known at particular <code>k</code> values but for which there is not a simple analytic form.</p>
<p>Cosmologists often express the power spectra in terms of an expansion in spherical harmonics (ell), i.e., the C_ell values. In the flat-sky limit, we can replace ell with k and C_ell with P(k). Thus, k and P(k) have dimensions of inverse angle and angle^2, respectively. It is quite common for people to plot ell(ell+1)C_ell/2pi, a dimensionless quantity; the analogous flat-sky quantity is Delta^2 = k^2 P(k)/2pi. By default, the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> object assumes it is getting P(k), but it is possible to instead give it Delta^2 by setting the optional keyword <code>delta2 = True</code> in the constructor.</p>
<p>The power functions must return a list/array that is the same size as what they are given, e.g., in the case of no power or constant power, a function that just returns a float would not be permitted; it would have to return an array of floats all with the same value.</p>
<p>It is important to note that the power spectra used to initialize the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> object should use the same units for k and P(k), i.e., if k is in inverse radians then P(k) should be in radians^2 (as is natural for outputs from a cosmological shear power spectrum calculator). However, when we actually draw images, there is a natural scale that defines the pitch of the image, which is typically taken to be arcsec. This definition of a specific length scale means that by default we assume all quantities to the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> are in arcsec, and those are the units used for internal calculations, but the <code>units</code> keyword can be used to specify different input units for P(k) (again, within the constraint that k and P(k) must be consistent). If the <code>delta2</code> keyword is set to specify that the input is actually the dimensionless power Delta^2, then the input <code>units</code> are taken to apply only to the k values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e_power_function</td><td>A function or other callable that accepts a NumPy array of |k| values, and returns the E-mode power spectrum P_E(|k|) in an array of the same shape. The function should return the power spectrum desired in the E (gradient) mode of the image. It may also be a string that can be converted to a function using `eval('lambda k : '+e_power_function)<code>, a LookupTable, or</code>file_name<code> from which to read in a LookupTable. If a</code>file_name` is given, the resulting LookupTable uses the defaults for the LookupTable class, namely spline interpolation in P(k). Users who wish to deviate from those defaults (for example, to interpolate in log(P) and log(k), as might be more natural for power-law functions) should instead read in the file to create a LookupTable using the necessary non-default settings. [default: None, which means no E-mode power.] </td></tr>
    <tr><td class="paramname">b_power_function</td><td>A function or other callable that accepts a NumPy array of |k| values, and returns the B-mode power spectrum P_B(|k|) in an array of the same shape. The function should return the power spectrum desired in the B (curl) mode of the image. See description of <code>e_power_function</code> for input format options. [default: None, which means no B-mode power.] </td></tr>
    <tr><td class="paramname">delta2</td><td>Is the power actually given as dimensionless Delta^2, which requires us to multiply by 2pi / k^2 to get the shear power P(k) in units of angle^2? [default: False] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the power spectrum (i.e. the units of k^-1 and sqrt(P)). This should be either an <a class="el" href="classgalsim_1_1_angle_unit.html" title="A class defining angle units. ">AngleUnit</a> instance (e.g. <a class="el" href="namespacegalsim.html#aed8d3e3dc27c52616a6006600ec00fea" title="constant with units of radians ">galsim.radians</a>) or a string (e.g. 'radians'). [default: arcsec] </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0bf7a88aee4e7f903a5fe8d19ea6cdf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta2</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afbfb65787431d770d9e1e9e842e61a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1f22414155c4cdcc6f32ee9079adcec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__hash__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d7c5a3ca3270ac6f63b3cf89e0e2ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30baffd37afb9a0fc94c0b3ed468ea2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a519ae191cdda24e7c8ddab47bff3eb17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2009ebd0aaab64683fcd60ba5b0d8069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.buildGrid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_spacing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ngrid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>galsim.PositionD(0,0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_convergence</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmax_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmin_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bandlimit</em> = <code>&quot;hard&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a realization of the current power spectrum on the specified grid. </p>
<h2>Basic functionality </h2>
<p>This function will generate a Gaussian random realization of the specified E and B mode shear power spectra at a grid of positions, specified by the input parameters <code>grid_spacing</code> (distance between grid points) and <code>ngrid</code> (number of grid points in each direction.) Units for <code>grid_spacing</code> and <code>center</code> can be specified using the <code>units</code> keyword; the default is arcsec, which is how all values are stored internally. It automatically computes and stores grids for the shears and convergence. However, since many users are primarily concerned with shape distortion due to shear, the default is to return only the shear components; the <code>get_convergence</code> keyword can be used to also return the convergence.</p>
<p>The quantities that are returned are the theoretical shears and convergences, usually denoted gamma and kappa, respectively. Users who wish to obtain the more observationally-relevant reduced shear and magnification (that describe real lensing distortions) can either use the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a97802ce5dd46c3741cb547a9886a5953" title="This function can interpolate between grid positions to find the lensing magnification (mu) values fo...">getMagnification()</a>, or <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afdd47f97e7402ca28cffc3e6dec8fe27" title="This function can interpolate between grid positions to find the lensing observable quantities (reduc...">getLensing()</a> methods after <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a>, or can use the convenience function <a class="el" href="namespacegalsim_1_1lensing__ps.html#a74a4dfa16142714963642f846b0a40d7" title="Helper function to convert theoretical lensing quantities to observed ones. ">galsim.lensing_ps.theoryToObserved()</a> to convert from theoretical to observed quantities.</p>
<h2>Effects of DFT approach, and keywords that can be used to ameliorate them </h2>
<p>Note that the shears generated using this method correspond to the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> multiplied by a sharp bandpass filter, set by the dimensions of the grid.</p>
<p>The filter sets <code>P(k)</code> = 0 for </p>
<pre class="fragment">|k1|, |k2| &lt; kmin / 2
</pre><p>and |k1|, |k2| &gt; kmax + kmin / 2</p>
<p>where kmin = 2. * pi / (ngrid * grid_spacing) kmax = pi / grid_spacing</p>
<p>and where we have adopted the convention that grid points at a given <code>k</code> represent the interval between (k - dk/2) and (k + dk/2) (noting that the grid spacing dk in k space is equivalent to <code>kmin</code>).</p>
<p>It is worth remembering that this bandpass filter will <em>not</em> look like a circular annulus in 2D <code>k</code> space, but is rather more like a thick-sided picture frame, having a small square central cutout of dimensions <code>kmin</code> by <code>kmin</code>. These properties are visible in the shears generated by this method.</p>
<p>If you care about these effects and want to ameliorate their effect, there are two optional kwargs you can provide: <code>kmin_factor</code> and <code>kmax_factor</code>, both of which are 1 by default. These should be integers &gt;= 1 that specify some factor smaller or larger (for kmin and kmax respectively) you want the code to use for the underlying grid in fourier space. The final shear grid is returned using the specified <code>ngrid</code> and <code>grid_spacing</code> parameters. But the intermediate grid in Fourier space will be larger by the specified factors.</p>
<p>Note: These are really just for convenience, since you could easily get the same effect by providing different values of ngrid and grid_spacing and then take a subset of them. The <code>kmin_factor</code> and <code>kmax_factor</code> just handle the scalings appropriately for you.</p>
<p>Use of <code>kmin_factor</code> and <code>kmax_factor</code> should depend on the desired application. For accurate representation of power spectra, one should not change these values from their defaults of 1. Changing them from one means the E- and B-mode power spectra that are input will be valid for the larger intermediate grids that get generated in Fourier space, but not necessarily for the smaller ones that get returned to the user. However, for accurate representation of cosmological shear correlation functions, use of <code>kmin_factor</code> larger than one can be helpful in getting the shear correlations closer to the ideal theoretical ones (see <code>devel/module/lensing_engine.pdf</code> for details).</p>
<h2>Aliasing </h2>
<p>If the user provides a power spectrum that does not include a cutoff at kmax, then our method of generating shears will result in aliasing that will show up in both E- and B-modes. Thus the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> method accepts an optional keyword argument called <code>bandlimit</code> that can tell the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> object to cut off power above kmax automatically, where the relevant kmax is larger than the grid Nyquist frequency by a factor of <code>kmax_factor</code>. The allowed values for <code>bandlimit</code> are None (i.e., do nothing), <code>hard</code> (set power to zero above the band limit), or <code>soft</code> (use an arctan-based softening function to make the power go gradually to zero above the band limit). By default, <code>bandlimit=hard</code>. Use of this keyword does nothing to the internal representation of the power spectrum, so if the user calls the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> method again, they will need to set <code>bandlimit</code> again (and if their grid setup is different in a way that changes <code>kmax</code>, then that's fine).</p>
<h2>Interpolation </h2>
<p>If the grid is being created for the purpose of later interpolating to random positions, the following findings should be kept in mind: since the interpolant modifies the effective shear correlation function on scales comparable to &lt;~3x the grid spacing, the grid spacing should be chosen to be at least 3 times smaller than the minimum scales on which the user wishes to reproduce the shear correlation function accurately. Ideally, the grid should be somewhat larger than the region in which shears at random points are needed, so that edge effects in the interpolation will not be important. For this purpose, there should be &gt;~5 grid points outside of the region in which interpolation will take place. Ignoring this edge effect and using the grid for interpolation out to its edges can suppress shear correlations on all scales by an amount that depends on the grid size; for a 100x100 grid, the suppression is ~2-3%. Note that the above numbers came from tests that use a cosmological shear power spectrum; precise figures for this suppression can also depend on the shear correlation function itself.</p>
<h2>Sign conventions and other info </h2>
<p>Note also that the convention for axis orientation differs from that for the GREAT10 challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2 shear component must be flipped.</p>
<p>For more information on the effects of finite grid representation of the power spectrum see <code>devel/modules/lensing_engine.pdf</code>.</p>
<p>Some examples:</p>
<ol type="1">
<li><p class="startli">Get shears on a grid of points separated by 1 arcsec: </p>
<pre class="fragment"> &gt;&gt;&gt; my_ps = galsim.PowerSpectrum(lambda k : k**2)
 &gt;&gt;&gt; g1, g2 = my_ps.buildGrid(grid_spacing = 1., ngrid = 100)
</pre><p class="startli">The returned g1, g2 are 2-d NumPy arrays of values, corresponding to the values of g1 and g2 at the locations of the grid points.</p>
<p class="startli">For a given value of <code>grid_spacing</code> and <code>ngrid</code>, we could get the x and y values on the grid using </p>
<pre class="fragment"> &gt;&gt;&gt; import numpy as np
 &gt;&gt;&gt; min = (-ngrid/2 + 0.5) * grid_spacing
 &gt;&gt;&gt; max = (ngrid/2 - 0.5) * grid_spacing
 &gt;&gt;&gt; x, y = np.meshgrid(np.arange(min,max+grid_spacing,grid_spacing),
 ...                    np.arange(min,max+grid_spacing,grid_spacing))
</pre><p class="startli">where the center of the grid is taken to be (0,0).</p>
</li>
<li>Rebuild the grid using a particular rng and set the location of the center of the grid to be something other than the default (0,0) <pre class="fragment"> &gt;&gt;&gt; g1, g2 = my_ps.buildGrid(grid_spacing = 8., ngrid = 65,
 ...                          rng = galsim.BaseDeviate(1413231),
 ...                          center = (256.5, 256.5) )
</pre></li>
<li>Make a <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> from a tabulated P(k) that gets interpolated to find the power at all necessary values of k, then generate shears and convergences on a grid, and convert to reduced shear and magnification so they can be used to transform galaxy images. Assuming that k and P_k are either lists, tuples, or 1d NumPy arrays containing k and P(k): <pre class="fragment"> &gt;&gt;&gt; tab_pk = galsim.LookupTable(k, P_k)
 &gt;&gt;&gt; my_ps = galsim.PowerSpectrum(tab_pk)
 &gt;&gt;&gt; g1, g2, kappa = my_ps.buildGrid(grid_spacing = 1., ngrid = 100,
 ...                                 get_convergence = True)
 &gt;&gt;&gt; g1_r, g2_r, mu = galsim.lensing_ps.theoryToObserved(g1, g2, kappa)
</pre></li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_spacing</td><td>Spacing for an evenly spaced grid of points, by default in arcsec for consistency with the natural length scale of images created using the drawImage() method. Other units can be specified using the <code>units</code> keyword. </td></tr>
    <tr><td class="paramname">ngrid</td><td>Number of grid points in each dimension. [Must be an integer] </td></tr>
    <tr><td class="paramname">rng</td><td>A <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object for drawing the random numbers. [default: None] </td></tr>
    <tr><td class="paramname">interpolant</td><td><a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears by methods like <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8a7ada810e77c7b4d1d6e24272a54661" title="This function can interpolate between grid positions to find the convergence values for a given list ...">getConvergence()</a>, etc. if they are later called. [default: <a class="el" href="classgalsim_1_1_lanczos.html" title="The Lanczos interpolation filter, nominally sinc(x)*sinc(x/n), truncated at +/-n. ...">galsim.Lanczos(5)</a>] </td></tr>
    <tr><td class="paramname">center</td><td>If setting up a new grid, define what position you want to consider the center of that grid. Units must be consistent with those for <code>grid_spacing</code>. [default: galsim.PositionD(0,0)] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default: arcsec] </td></tr>
    <tr><td class="paramname">get_convergence</td><td>Return the convergence in addition to the shear? Regardless of the value of <code>get_convergence</code>, the convergence will still be computed and stored for future use. [default: False] </td></tr>
    <tr><td class="paramname">kmin_factor</td><td>Factor by which the grid spacing in fourier space is smaller than the default. i.e. kmin = 2. * pi / (ngrid * grid_spacing) / kmin_factor [default: 1; must be an integer] </td></tr>
    <tr><td class="paramname">kmax_factor</td><td>Factor by which the overall grid in fourier space is larger than the default. i.e. kmax = pi / grid_spacing * kmax_factor [default: 1; must be an integer] </td></tr>
    <tr><td class="paramname">bandlimit</td><td>Keyword determining how to handle power P(k) above the limiting k value, kmax. The options None, 'hard', and 'soft' correspond to doing nothing (i.e., allow P(&gt;kmax) to be aliased to lower k values), cutting off all power above kmax, and applying a softening filter to gradually cut off power above kmax. Use of this keyword does not modify the internally-stored power spectrum, just the shears generated for this particular call to <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a>. [default: "hard"]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple (g1,g2[,kappa]), where each is a 2-d NumPy array and kappa is included iff <code>get_convergence</code> is set to True. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d192ea3aa594fbf46c044c5292bfcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.calculateXi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ngrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmax_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmin_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_theta</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bandlimit</em> = <code>&quot;hard&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate shear correlation functions for the current power spectrum on the specified grid. </p>
<p>This function will calculate the theoretical shear correlation functions, xi_+ and xi_-, for this power spectrum and the grid configuration specified using keyword arguments, taking into account the minimum and maximum k range implied by the grid parameters, <code>kmin_factor</code>, and <code>kmax_factor</code>. Most theoretical correlation function calculators assume an infinite k range, so this utility can be used to check how close the chosen grid parameters (and the implied minimum and maximum k) come to the "ideal" result. This is particularly useful on large scales, since in practice the finite grid extent limits the minimum k value and therefore can suppress shear correlations on large scales. Note that the actual shear correlation function in the generated shears will still differ from the one calculated here due to differences between the discrete and continuous Fourier transform.</p>
<p>The quantities that are returned are three NumPy arrays: separation theta (in the adopted units), xi_+, and xi_-. These are defined in terms of the E- and B-mode shear power spectrum as in the document <code>devel/modules/lensing_engine.pdf</code>, equations 2 and 3. The values that are returned are for a particular theta value, not an average over a range of theta values in some bin of finite width.</p>
<p>This method has been tested with cosmological shear power spectra; users should check for sanity of outputs if attempting to use power spectra that have very different scalings with k.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_spacing</td><td>Spacing for an evenly spaced grid of points, by default in arcsec for consistency with the natural length scale of images created using the drawImage() method. Other units can be specified using the <code>units</code> keyword. </td></tr>
    <tr><td class="paramname">ngrid</td><td>Number of grid points in each dimension. [Must be an integer] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec] </td></tr>
    <tr><td class="paramname">kmin_factor</td><td>(Optional) Factor by which the grid spacing in fourier space is smaller than the default. i.e. kmin = 2. * pi / (ngrid * grid_spacing) / kmin_factor [default <code>kmin_factor = 1</code>; must be an integer] </td></tr>
    <tr><td class="paramname">kmax_factor</td><td>(Optional) Factor by which the overall grid in fourier space is larger than the default. i.e. kmax = pi / grid_spacing * kmax_factor [default <code>kmax_factor = 1</code>; must be an integer] </td></tr>
    <tr><td class="paramname">n_theta</td><td>(Optional) Number of logarithmically spaced bins in angular separation. [default <code>n_theta=100</code>] </td></tr>
    <tr><td class="paramname">bandlimit</td><td>(Optional) Keyword determining how to handle power P(k) above the limiting k value, kmax. The options None, 'hard', and 'soft' correspond to doing nothing (i.e., allow P(&gt;kmax) to be aliased to lower k values), cutting off all power above kmax, and applying a softening filter to gradually cut off power above kmax. Use of this keyword does not modify the internally-stored power spectrum, just the result generated by this particular call to <code>calculateXi</code>. [default <code>bandlimit="hard"</code>]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple (theta, xi_p, xi_m), 1-d NumPy arrays for the angular separation theta and the two shear correlation functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a7ada810e77c7b4d1d6e24272a54661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getConvergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the convergence values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> first to define the grid of convergences on which to interpolate. The docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> provides some guidance on appropriate grid configurations to use when building a grid that is to be later interpolated to random positions.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears and convergence, if none is specified here) modifies the effective 2-point functions of these quantities. See docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> docstring for caveats about interpolation. The user is advised to be very careful about deviating from the default Lanczos-5 interpolant.</p>
<p>The usage of <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8a7ada810e77c7b4d1d6e24272a54661" title="This function can interpolate between grid positions to find the convergence values for a given list ...">getConvergence()</a> is the same as for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, except that it returns only a single quantity (convergence value or array of convergence values) rather than two quantities. See documentation for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default: arcsec] </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether the interpolation should treat the positions as being defined with respect to a periodic grid, which will wrap them around if they are outside the bounds of the original grid on which shears and convergences were defined. If not, then convergences are set to zero for positions outside the original grid. [default: False] </td></tr>
    <tr><td class="paramname">interpolant</td><td><a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears. By default, the one that was specified when building the grid was used. Specifying an interpolant here does not change the one that is stored as part of this <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> instance. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convergence, kappa.</dd></dl>
<p>If the input <code>pos</code> is given a single position, kappa is the convergence value. If the input <code>pos</code> is given a list of positions, kappa is a python list of values. If the input <code>pos</code> is given a NumPy array of positions, kappa is a NumPy array. </p>

</div>
</div>
<a class="anchor" id="afdd47f97e7402ca28cffc3e6dec8fe27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getLensing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the lensing observable quantities (reduced shears g1 and g2, and magnification mu) for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> first to define the grid of shears and convergences on which to interpolate. The docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> provides some guidance on appropriate grid configurations to use when building a grid that is to be later interpolated to random positions.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears and convergence, if none is specified here) modifies the effective 2-point functions of these quantities. See docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> docstring for caveats about interpolation. The user is advised to be very careful about deviating from the default Lanczos-5 interpolant.</p>
<p>The usage of <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afdd47f97e7402ca28cffc3e6dec8fe27" title="This function can interpolate between grid positions to find the lensing observable quantities (reduc...">getLensing()</a> is the same as for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, except that it returns three quantities (two reduced shear components and magnification) rather than two. See documentation for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default: arcsec] </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether the interpolation should treat the positions as being defined with respect to a periodic grid, which will wrap them around if they are outside the bounds of the original grid on which shears and convergences were defined. If not, then shear is set to zero and magnification is set to 1 for positions outside the original grid. [default: False] </td></tr>
    <tr><td class="paramname">interpolant</td><td><a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears. By default, the one that was specified when building the grid was used. Specifying an interpolant here does not change the one that is stored as part of this <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> instance. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shear and magnification as a tuple (g1,g2,mu).</dd></dl>
<p>If the input <code>pos</code> is given a single position, the return values are the shear and magnification values at that position. If the input <code>pos</code> is given a list of positions, they are python lists of values. If the input <code>pos</code> is given a NumPy array of positions, they are NumPy arrays. </p>

</div>
</div>
<a class="anchor" id="a97802ce5dd46c3741cb547a9886a5953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getMagnification </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the lensing magnification (mu) values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> first to define the grid of shears and convergences on which to interpolate. The docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> provides some guidance on appropriate grid configurations to use when building a grid that is to be later interpolated to random positions.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears and convergence, if none is specified here) modifies the effective 2-point functions of these quantities. See docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> docstring for caveats about interpolation. The user is advised to be very careful about deviating from the default Lanczos-5 interpolant.</p>
<p>The usage of <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a97802ce5dd46c3741cb547a9886a5953" title="This function can interpolate between grid positions to find the lensing magnification (mu) values fo...">getMagnification()</a> is the same as for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, except that it returns only a single quantity (a magnification value or array of magnification values) rather than a pair of quantities. See documentation for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default: arcsec] </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether the interpolation should treat the positions as being defined with respect to a periodic grid, which will wrap them around if they are outside the bounds of the original grid on which shears and convergences were defined. If not, then magnification is set to 1 for positions outside the original grid. [default: False] </td></tr>
    <tr><td class="paramname">interpolant</td><td><a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears. By default, the one that was specified when building the grid was used. Specifying an interpolant here does not change the one that is stored as part of this <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> instance. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the magnification, mu.</dd></dl>
<p>If the input <code>pos</code> is given a single position, mu is the magnification value. If the input <code>pos</code> is given a list of positions, mu is a python list of values. If the input <code>pos</code> is given a NumPy array of positions, mu is a NumPy array. </p>

</div>
</div>
<a class="anchor" id="a0b1354152d2b348a2fbe33bd8367f041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getShear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduced</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> first to define the grid of shears and convergences on which to interpolate. The docstring for <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> provides some guidance on appropriate grid configurations to use when building a grid that is to be later interpolated to random positions.</p>
<p>By default, this method returns the reduced shear, which is defined in terms of shear and convergence as reduced shear <code>g=gamma/(1-kappa)</code>; the <code>reduced</code> keyword can be set to False in order to return the non-reduced shear.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears, if none is specified here) modifies the effective shear power spectrum and correlation function somewhat, though the effects can be limited by careful choice of grid parameters (see <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a> docstring for details). Assuming those guidelines are followed, then the shear correlation function modifications due to use of the quintic, Lanczos-3, and Lanczos-5 interpolants are below 5% on all scales from the grid spacing to the total grid extent, typically below 2%. The linear, cubic, and nearest interpolants perform significantly more poorly, with modifications of the correlation functions that can reach tens of percent on the scales where the recommended interpolants perform well. Thus, the default interpolant is Lanczos-5, and users should think carefully about the acceptability of significant modification of the shear correlation function before changing to use linear, cubic, or nearest.</p>
<p>Users who wish to ensure that the shear power spectrum is preserved post-interpolation should consider using the <code>periodic</code> interpolation option, which assumes the shear field is periodic (i.e., the sky is tiled with many copies of the given shear field). Those who care about the correlation function should not use this option, and for this reason it's not the default.</p>
<p>Some examples of how to use <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>:</p>
<ol type="1">
<li><p class="startli">Get the shear for a particular point: </p>
<pre class="fragment"> &gt;&gt;&gt; g1, g2 = my_ps.getShear(pos = galsim.PositionD(12, 412))
</pre><p class="startli">This time the returned values are just floats and correspond to the shear for the provided position.</p>
</li>
<li>You can also provide a position as a tuple to save the explicit PositionD construction: <pre class="fragment"> &gt;&gt;&gt; g1, g2 = my_ps.getShear(pos = (12, 412))
</pre></li>
<li><p class="startli">Get the shears for a bunch of points at once: </p>
<pre class="fragment"> &gt;&gt;&gt; xlist = [ 141, 313,  12, 241, 342 ]
 &gt;&gt;&gt; ylist = [  75, 199, 306, 225, 489 ]
 &gt;&gt;&gt; poslist = [ galsim.PositionD(xlist[i],ylist[i]) for i in range(len(xlist)) ]
 &gt;&gt;&gt; g1, g2 = my_ps.getShear( poslist )
 &gt;&gt;&gt; g1, g2 = my_ps.getShear( (xlist, ylist) )
</pre><p class="startli">Both calls do the same thing. The returned g1, g2 this time are lists of g1, g2 values. The lists are the same length as the number of input positions.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default: arcsec] </td></tr>
    <tr><td class="paramname">reduced</td><td>Whether returned shear(s) should be reduced shears. [default: True] </td></tr>
    <tr><td class="paramname">periodic</td><td>Whether the interpolation should treat the positions as being defined with respect to a periodic grid, which will wrap them around if they are outside the bounds of the original grid on which shears were defined. If not, then shears are set to zero for positions outside the original grid. [default: False] </td></tr>
    <tr><td class="paramname">interpolant</td><td><a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears. By default, the one that was specified when building the grid was used. Specifying an interpolant here does not change the one that is stored as part of this <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k). ">PowerSpectrum</a> instance. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shear as a tuple, (g1,g2)</dd></dl>
<p>If the input <code>pos</code> is given a single position, (g1,g2) are the two shear components. If the input <code>pos</code> is given a list of positions, they are each a python list of values. If the input <code>pos</code> is given a NumPy array of positions, they are NumPy arrays. </p>

</div>
</div>
<a class="anchor" id="a96dde5ca70773d8f57eecb1f5bdb642c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.nRandCallsForBuildGrid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of times the rng() was called the last time buildGrid was called. </p>
<p>This can be useful for keeping rngs in sync if the connection between them is broken (e.g. when calling the function through a Proxy object). </p>

</div>
</div>
<a class="anchor" id="ad312cc52f9a3b4ea51221b16b01ffbe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.subsampleGrid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subsample_fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_convergence</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to use a regular subset of the grid points without a completely new call to <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a>. </p>
<p>This routine can be used after <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069" title="Generate a realization of the current power spectrum on the specified grid. ">buildGrid()</a>, in order to use a subset of the grid points corresponding to every Nth point along both dimensions. All internally-stored parameters such as the shear and convergence values, the grid spacing, etc. get properly updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsample_fac</td><td>Factor by which to subsample the gridded shear and convergence fields. This is currently required to be a factor of <code>ngrid</code>. </td></tr>
    <tr><td class="paramname">get_convergence</td><td>Return the convergence in addition to the shear? Regardless of the value of <code>get_convergence</code>, the convergence will still be computed and stored for future use. [default: <code>False</code>] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a424bc6120a3d57678928a7594599e33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.adjust_center</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1680823e5f523dbd6bd29b14a7a8f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.b_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0931e6f1a8d4950ffd770fe76d5789ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.bounds</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1c78817f9b04e27c7c292b2505bdb7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.center</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a92406265cb8e981948c8008c5f1b56af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.delta2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ade197b0cbf8fb086299ffa00dac880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.e_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5d639842746d63c080f60c26b42276b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a932204e8e0d4d1c0874af50d65f1df3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bad4165ff17f51b67bb11c170631a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f3cac5d382324aba8021271cc948647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_spacing</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a746956592b3f704836aff1fce0edbfcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe1d0edc315b8bf523bd1146d1227aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a348c91e43ddb19bde34b944426f6ca83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7700448eb709d4abc8f4fc0575fe22d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.interpolant</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d883a1d05717714b99b13d71b010b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.ngrid_tot</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aa33a055585d247753d7b4270b69fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.pixel_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a214736f544af923f42a17ca5fb1195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.scale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af42cab4637dbee68b9b118f266a7bfda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.units</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="lensing__ps_8py.html">lensing_ps.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
