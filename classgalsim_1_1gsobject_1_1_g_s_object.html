<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.gsobject.GSObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1gsobject.html">gsobject</a></li><li class="navelem"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html">GSObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgalsim_1_1gsobject_1_1_g_s_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim.gsobject.GSObject Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all GalSim classes that represent some kind of surface brightness profile.  
 <a href="classgalsim_1_1gsobject_1_1_g_s_object.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for galsim.gsobject.GSObject:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1gsobject_1_1_g_s_object.png" usemap="#galsim.gsobject.GSObject_map" alt=""/>
  <map id="galsim.gsobject.GSObject_map" name="galsim.gsobject.GSObject_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48338aff4532994d9e3b3b9c01ec7530"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a48338aff4532994d9e3b3b9c01ec7530">__init__</a></td></tr>
<tr class="separator:a48338aff4532994d9e3b3b9c01ec7530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca82815f68409e324fca1caf46d8a1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a7ca82815f68409e324fca1caf46d8a1c">SBProfile</a></td></tr>
<tr class="separator:a7ca82815f68409e324fca1caf46d8a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52713c692124c1419e71690c1f3a8e8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a52713c692124c1419e71690c1f3a8e8e">noise</a></td></tr>
<tr class="separator:a52713c692124c1419e71690c1f3a8e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0817750dfb31833cf47cc399d4699ad1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a0817750dfb31833cf47cc399d4699ad1">separable</a></td></tr>
<tr class="separator:a0817750dfb31833cf47cc399d4699ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c76de460e6e8a492c40642aa718956"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ab8c76de460e6e8a492c40642aa718956">interpolated</a></td></tr>
<tr class="separator:ab8c76de460e6e8a492c40642aa718956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bdbbb228af6bee2c839b6860afa8d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ad3bdbbb228af6bee2c839b6860afa8d9">deinterpolated</a></td></tr>
<tr class="separator:ad3bdbbb228af6bee2c839b6860afa8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee61aad28535bc5486b6f8fdfdca6dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a4ee61aad28535bc5486b6f8fdfdca6dc">SED</a></td></tr>
<tr class="separator:a4ee61aad28535bc5486b6f8fdfdca6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf48bfd51ca8c10eec21137f78941b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aedf48bfd51ca8c10eec21137f78941b7">spectral</a></td></tr>
<tr class="separator:aedf48bfd51ca8c10eec21137f78941b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71058b4578a2a1ff04bbe10d58be4d40"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a71058b4578a2a1ff04bbe10d58be4d40">dimensionless</a></td></tr>
<tr class="separator:a71058b4578a2a1ff04bbe10d58be4d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fcfe5d0f71eb772969567a4f94d62c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ae8fcfe5d0f71eb772969567a4f94d62c">wave_list</a></td></tr>
<tr class="separator:ae8fcfe5d0f71eb772969567a4f94d62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502a92a52f1d58cdfc55b2d1cd37617"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a2502a92a52f1d58cdfc55b2d1cd37617">evaluateAtWavelength</a></td></tr>
<tr class="memdesc:a2502a92a52f1d58cdfc55b2d1cd37617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return profile at a given wavelength.  <a href="#a2502a92a52f1d58cdfc55b2d1cd37617">More...</a><br/></td></tr>
<tr class="separator:a2502a92a52f1d58cdfc55b2d1cd37617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e318ee4a675c83a63472df5ba826a41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a9e318ee4a675c83a63472df5ba826a41">__add__</a></td></tr>
<tr class="separator:a9e318ee4a675c83a63472df5ba826a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01cefd5df227baeb21f981edd5cb0c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ae01cefd5df227baeb21f981edd5cb0c3">__sub__</a></td></tr>
<tr class="separator:ae01cefd5df227baeb21f981edd5cb0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ae78d7b08052ee9fe3a4c242c01c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a045ae78d7b08052ee9fe3a4c242c01c7">__mul__</a></td></tr>
<tr class="memdesc:a045ae78d7b08052ee9fe3a4c242c01c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the flux of the object by the given factor.  <a href="#a045ae78d7b08052ee9fe3a4c242c01c7">More...</a><br/></td></tr>
<tr class="separator:a045ae78d7b08052ee9fe3a4c242c01c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada028fbaa5f466eb539ab8216417bc3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ada028fbaa5f466eb539ab8216417bc3c">__rmul__</a></td></tr>
<tr class="memdesc:ada028fbaa5f466eb539ab8216417bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * other.  <a href="#ada028fbaa5f466eb539ab8216417bc3c">More...</a><br/></td></tr>
<tr class="separator:ada028fbaa5f466eb539ab8216417bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce5e57bb992fcd021473c287e1f09e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a0ce5e57bb992fcd021473c287e1f09e5">__div__</a></td></tr>
<tr class="memdesc:a0ce5e57bb992fcd021473c287e1f09e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * (1/other)  <a href="#a0ce5e57bb992fcd021473c287e1f09e5">More...</a><br/></td></tr>
<tr class="separator:a0ce5e57bb992fcd021473c287e1f09e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405a8ab440a5f45ed928056b912711b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a405a8ab440a5f45ed928056b912711b3">__neg__</a></td></tr>
<tr class="separator:a405a8ab440a5f45ed928056b912711b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40af39da0fab05eae24db987ea9504d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac40af39da0fab05eae24db987ea9504d">maxk</a></td></tr>
<tr class="memdesc:ac40af39da0fab05eae24db987ea9504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of k beyond which aliasing can be neglected.  <a href="#ac40af39da0fab05eae24db987ea9504d">More...</a><br/></td></tr>
<tr class="separator:ac40af39da0fab05eae24db987ea9504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa432af2a0aaaf87c46c9da12eb4010f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aaa432af2a0aaaf87c46c9da12eb4010f">stepk</a></td></tr>
<tr class="memdesc:aaa432af2a0aaaf87c46c9da12eb4010f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sampling in k space necessary to avoid folding of image in x space.  <a href="#aaa432af2a0aaaf87c46c9da12eb4010f">More...</a><br/></td></tr>
<tr class="separator:aaa432af2a0aaaf87c46c9da12eb4010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ec66e641a5f29337b5f42e97960cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#afc5ec66e641a5f29337b5f42e97960cd">nyquist_scale</a></td></tr>
<tr class="memdesc:afc5ec66e641a5f29337b5f42e97960cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Image pixel spacing that does not alias maxk.  <a href="#afc5ec66e641a5f29337b5f42e97960cd">More...</a><br/></td></tr>
<tr class="separator:afc5ec66e641a5f29337b5f42e97960cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d107ccdab66e3bcd65067c2c6ca348e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a1d107ccdab66e3bcd65067c2c6ca348e">has_hard_edges</a></td></tr>
<tr class="memdesc:a1d107ccdab66e3bcd65067c2c6ca348e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain.  <a href="#a1d107ccdab66e3bcd65067c2c6ca348e">More...</a><br/></td></tr>
<tr class="separator:a1d107ccdab66e3bcd65067c2c6ca348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454f827d264c257582424ccac0c17a71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a454f827d264c257582424ccac0c17a71">is_axisymmetric</a></td></tr>
<tr class="memdesc:a454f827d264c257582424ccac0c17a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wthether the profile is axially symmetric; affects efficiency of evaluation.  <a href="#a454f827d264c257582424ccac0c17a71">More...</a><br/></td></tr>
<tr class="separator:a454f827d264c257582424ccac0c17a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79556f8e9ed661b1b3f1ce5cc61d425a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a79556f8e9ed661b1b3f1ce5cc61d425a">is_analytic_x</a></td></tr>
<tr class="memdesc:a79556f8e9ed661b1b3f1ce5cc61d425a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#a79556f8e9ed661b1b3f1ce5cc61d425a">More...</a><br/></td></tr>
<tr class="separator:a79556f8e9ed661b1b3f1ce5cc61d425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11539f6fa17581075b119536e65e842f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a11539f6fa17581075b119536e65e842f">is_analytic_k</a></td></tr>
<tr class="memdesc:a11539f6fa17581075b119536e65e842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#a11539f6fa17581075b119536e65e842f">More...</a><br/></td></tr>
<tr class="separator:a11539f6fa17581075b119536e65e842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428ec61c500c299eaf83185794d0fd1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3428ec61c500c299eaf83185794d0fd1">centroid</a></td></tr>
<tr class="memdesc:a3428ec61c500c299eaf83185794d0fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>.  <a href="#a3428ec61c500c299eaf83185794d0fd1">More...</a><br/></td></tr>
<tr class="separator:a3428ec61c500c299eaf83185794d0fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc89dc8d1c65806516c53f31d74b4ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#acbc89dc8d1c65806516c53f31d74b4ae">positive_flux</a></td></tr>
<tr class="memdesc:acbc89dc8d1c65806516c53f31d74b4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The expectation value of the flux in positive photons when <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac2d8564b67da04c55ecb4f0b882a8f96" title="Shoot photons into a PhotonArray. ">shoot()</a> is called.  <a href="#acbc89dc8d1c65806516c53f31d74b4ae">More...</a><br/></td></tr>
<tr class="separator:acbc89dc8d1c65806516c53f31d74b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd22388666a94b6f96786c4e8574292"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#addd22388666a94b6f96786c4e8574292">negative_flux</a></td></tr>
<tr class="memdesc:addd22388666a94b6f96786c4e8574292"><td class="mdescLeft">&#160;</td><td class="mdescRight">The expectation value of the flux in negative photons when <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac2d8564b67da04c55ecb4f0b882a8f96" title="Shoot photons into a PhotonArray. ">shoot()</a> is called.  <a href="#addd22388666a94b6f96786c4e8574292">More...</a><br/></td></tr>
<tr class="separator:addd22388666a94b6f96786c4e8574292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa197c3102b55343145dabc3d1a2209"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#acfa197c3102b55343145dabc3d1a2209">max_sb</a></td></tr>
<tr class="memdesc:acfa197c3102b55343145dabc3d1a2209"><td class="mdescLeft">&#160;</td><td class="mdescRight">An estimate of the maximum surface brightness of the object.  <a href="#acfa197c3102b55343145dabc3d1a2209">More...</a><br/></td></tr>
<tr class="separator:acfa197c3102b55343145dabc3d1a2209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925aed2e591399c744c4ddceccb304d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a925aed2e591399c744c4ddceccb304d6">maxK</a></td></tr>
<tr class="separator:a925aed2e591399c744c4ddceccb304d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f3ac816884d0f2f5a32939d87b40fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a62f3ac816884d0f2f5a32939d87b40fc">nyquistScale</a></td></tr>
<tr class="separator:a62f3ac816884d0f2f5a32939d87b40fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d349d31f1feb37c4ba678bb411e2ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ad7d349d31f1feb37c4ba678bb411e2ae">stepK</a></td></tr>
<tr class="separator:ad7d349d31f1feb37c4ba678bb411e2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7449e6df8bf5cff587db3817333ca74"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ae7449e6df8bf5cff587db3817333ca74">hasHardEdges</a></td></tr>
<tr class="separator:ae7449e6df8bf5cff587db3817333ca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e69481a5c6b0babaa907056b067f67"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a52e69481a5c6b0babaa907056b067f67">isAxisymmetric</a></td></tr>
<tr class="separator:a52e69481a5c6b0babaa907056b067f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08fda46012fb257906bab49ed084a33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#af08fda46012fb257906bab49ed084a33">isAnalyticX</a></td></tr>
<tr class="separator:af08fda46012fb257906bab49ed084a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0399146659893722e457d996c61cd5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#acf0399146659893722e457d996c61cd5">isAnalyticK</a></td></tr>
<tr class="separator:acf0399146659893722e457d996c61cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afd2e68c557ef14ba8b6770e027dc62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a1afd2e68c557ef14ba8b6770e027dc62">getFlux</a></td></tr>
<tr class="separator:a1afd2e68c557ef14ba8b6770e027dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992c51c7af6fcaa104c9e3e3b8df0e5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a992c51c7af6fcaa104c9e3e3b8df0e5a">getPositiveFlux</a></td></tr>
<tr class="separator:a992c51c7af6fcaa104c9e3e3b8df0e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb86711851c112d5e303ba4f392755"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a1dfb86711851c112d5e303ba4f392755">getNegativeFlux</a></td></tr>
<tr class="separator:a1dfb86711851c112d5e303ba4f392755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5e7e6d59f09e48e53ed566c54fdc49"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#afe5e7e6d59f09e48e53ed566c54fdc49">maxSB</a></td></tr>
<tr class="separator:afe5e7e6d59f09e48e53ed566c54fdc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5c4faf1ec76d936de2e88330396ce6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aea5c4faf1ec76d936de2e88330396ce6">getGSParams</a></td></tr>
<tr class="separator:aea5c4faf1ec76d936de2e88330396ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e1e223bae1d88d24f4f7808cd2a8ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a52e1e223bae1d88d24f4f7808cd2a8ab">calculateHLR</a></td></tr>
<tr class="memdesc:a52e1e223bae1d88d24f4f7808cd2a8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the half-light radius of the object.  <a href="#a52e1e223bae1d88d24f4f7808cd2a8ab">More...</a><br/></td></tr>
<tr class="separator:a52e1e223bae1d88d24f4f7808cd2a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2e52914acb931e42713fbce263ac6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a8db2e52914acb931e42713fbce263ac6">calculateMomentRadius</a></td></tr>
<tr class="memdesc:a8db2e52914acb931e42713fbce263ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the radius based on unweighted second moments.  <a href="#a8db2e52914acb931e42713fbce263ac6">More...</a><br/></td></tr>
<tr class="separator:a8db2e52914acb931e42713fbce263ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf633d1aee3ef1739a5377436afc76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ae4cf633d1aee3ef1739a5377436afc76">calculateFWHM</a></td></tr>
<tr class="memdesc:ae4cf633d1aee3ef1739a5377436afc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full-width half-maximum (FWHM) of the object.  <a href="#ae4cf633d1aee3ef1739a5377436afc76">More...</a><br/></td></tr>
<tr class="separator:ae4cf633d1aee3ef1739a5377436afc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf1843da478c2369a35cfbfdbccaa96"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a5cf1843da478c2369a35cfbfdbccaa96">flux</a></td></tr>
<tr class="separator:a5cf1843da478c2369a35cfbfdbccaa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb0162c8cfad9acc8d178dc6e12fd4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a2eb0162c8cfad9acc8d178dc6e12fd4e">gsparams</a></td></tr>
<tr class="separator:a2eb0162c8cfad9acc8d178dc6e12fd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f44f1d019c34634a41a89c06c9f631"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a51f44f1d019c34634a41a89c06c9f631">xValue</a></td></tr>
<tr class="memdesc:a51f44f1d019c34634a41a89c06c9f631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in real space.  <a href="#a51f44f1d019c34634a41a89c06c9f631">More...</a><br/></td></tr>
<tr class="separator:a51f44f1d019c34634a41a89c06c9f631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a924e2d85a44389099bd8e74e591017"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a7a924e2d85a44389099bd8e74e591017">kValue</a></td></tr>
<tr class="memdesc:a7a924e2d85a44389099bd8e74e591017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in k space.  <a href="#a7a924e2d85a44389099bd8e74e591017">More...</a><br/></td></tr>
<tr class="separator:a7a924e2d85a44389099bd8e74e591017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d45679dfc86f63e46de5524639bb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#abc8d45679dfc86f63e46de5524639bb3">withFlux</a></td></tr>
<tr class="memdesc:abc8d45679dfc86f63e46de5524639bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a different flux.  <a href="#abc8d45679dfc86f63e46de5524639bb3">More...</a><br/></td></tr>
<tr class="separator:abc8d45679dfc86f63e46de5524639bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b00698a20025ead0678dc1bd847853"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a39b00698a20025ead0678dc1bd847853">withScaledFlux</a></td></tr>
<tr class="memdesc:a39b00698a20025ead0678dc1bd847853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>.  <a href="#a39b00698a20025ead0678dc1bd847853">More...</a><br/></td></tr>
<tr class="separator:a39b00698a20025ead0678dc1bd847853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ebb301de472bdd366210422ea32f7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a68ebb301de472bdd366210422ea32f7d">expand</a></td></tr>
<tr class="memdesc:a68ebb301de472bdd366210422ea32f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness.  <a href="#a68ebb301de472bdd366210422ea32f7d">More...</a><br/></td></tr>
<tr class="separator:a68ebb301de472bdd366210422ea32f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26483093b11e5a0264ee3e0f3ad5acf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aa26483093b11e5a0264ee3e0f3ad5acf">dilate</a></td></tr>
<tr class="memdesc:aa26483093b11e5a0264ee3e0f3ad5acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux.  <a href="#aa26483093b11e5a0264ee3e0f3ad5acf">More...</a><br/></td></tr>
<tr class="separator:aa26483093b11e5a0264ee3e0f3ad5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d40a46404ea7674af47459c975e333b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b">magnify</a></td></tr>
<tr class="memdesc:a3d40a46404ea7674af47459c975e333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by <code>mu</code> at fixed surface brightness.  <a href="#a3d40a46404ea7674af47459c975e333b">More...</a><br/></td></tr>
<tr class="separator:a3d40a46404ea7674af47459c975e333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a9c46634d62f37ff5cb7358ce73a85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a93a9c46634d62f37ff5cb7358ce73a85">shear</a></td></tr>
<tr class="memdesc:a93a9c46634d62f37ff5cb7358ce73a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an area-preserving shear applied to it.  <a href="#a93a9c46634d62f37ff5cb7358ce73a85">More...</a><br/></td></tr>
<tr class="separator:a93a9c46634d62f37ff5cb7358ce73a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d5076291c11a8f0ebd1e75942be4ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a55d5076291c11a8f0ebd1e75942be4ec">lens</a></td></tr>
<tr class="memdesc:a55d5076291c11a8f0ebd1e75942be4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with both a lensing shear and magnification applied to it.  <a href="#a55d5076291c11a8f0ebd1e75942be4ec">More...</a><br/></td></tr>
<tr class="separator:a55d5076291c11a8f0ebd1e75942be4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6154d3b762748b3441dd547d41593cc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a6154d3b762748b3441dd547d41593cc4">rotate</a></td></tr>
<tr class="memdesc:a6154d3b762748b3441dd547d41593cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> <code>theta</code>.  <a href="#a6154d3b762748b3441dd547d41593cc4">More...</a><br/></td></tr>
<tr class="separator:a6154d3b762748b3441dd547d41593cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572f542a2150a588f43389e9f30b273"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a1572f542a2150a588f43389e9f30b273">transform</a></td></tr>
<tr class="memdesc:a1572f542a2150a588f43389e9f30b273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it.  <a href="#a1572f542a2150a588f43389e9f30b273">More...</a><br/></td></tr>
<tr class="separator:a1572f542a2150a588f43389e9f30b273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41314ad780e3f646f2194bf372465bfa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a41314ad780e3f646f2194bf372465bfa">shift</a></td></tr>
<tr class="memdesc:a41314ad780e3f646f2194bf372465bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object shifted by some amount in real space.  <a href="#a41314ad780e3f646f2194bf372465bfa">More...</a><br/></td></tr>
<tr class="separator:a41314ad780e3f646f2194bf372465bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c2e0b2207854148cd060957808076c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c">drawImage</a></td></tr>
<tr class="memdesc:a67c2e0b2207854148cd060957808076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an Image of the object.  <a href="#a67c2e0b2207854148cd060957808076c">More...</a><br/></td></tr>
<tr class="separator:a67c2e0b2207854148cd060957808076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c8f475eea12dec5b66dfb140f177e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a5e0c8f475eea12dec5b66dfb140f177e">drawReal</a></td></tr>
<tr class="memdesc:a5e0c8f475eea12dec5b66dfb140f177e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this profile into an Image by direct evaluation at the location of each pixel.  <a href="#a5e0c8f475eea12dec5b66dfb140f177e">More...</a><br/></td></tr>
<tr class="separator:a5e0c8f475eea12dec5b66dfb140f177e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37480bc89b03769478f673b6e854e968"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a37480bc89b03769478f673b6e854e968">getGoodImageSize</a></td></tr>
<tr class="memdesc:a37480bc89b03769478f673b6e854e968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a good size to use for drawing this profile.  <a href="#a37480bc89b03769478f673b6e854e968">More...</a><br/></td></tr>
<tr class="separator:a37480bc89b03769478f673b6e854e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdaeaa677f2cfcc7e33374dd8c3fd68"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a9cdaeaa677f2cfcc7e33374dd8c3fd68">drawFFT_makeKImage</a></td></tr>
<tr class="memdesc:a9cdaeaa677f2cfcc7e33374dd8c3fd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper routine for drawFFT that just makes the (blank) k-space image onto which the profile will be drawn.  <a href="#a9cdaeaa677f2cfcc7e33374dd8c3fd68">More...</a><br/></td></tr>
<tr class="separator:a9cdaeaa677f2cfcc7e33374dd8c3fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2cee1943d989834de0823f9d581218"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a5d2cee1943d989834de0823f9d581218">drawFFT_finish</a></td></tr>
<tr class="memdesc:a5d2cee1943d989834de0823f9d581218"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper routine for drawFFT that finishes the calculation, based on the drawn k-space image.  <a href="#a5d2cee1943d989834de0823f9d581218">More...</a><br/></td></tr>
<tr class="separator:a5d2cee1943d989834de0823f9d581218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5fc663b598862f9a003955eee8e3d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aad5fc663b598862f9a003955eee8e3d0">drawFFT</a></td></tr>
<tr class="memdesc:aad5fc663b598862f9a003955eee8e3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this profile into an Image by computing the k-space image and performing an FFT.  <a href="#aad5fc663b598862f9a003955eee8e3d0">More...</a><br/></td></tr>
<tr class="separator:aad5fc663b598862f9a003955eee8e3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92698ce57d3517d9b281653dcf83da18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a92698ce57d3517d9b281653dcf83da18">drawPhot</a></td></tr>
<tr class="memdesc:a92698ce57d3517d9b281653dcf83da18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this profile into an Image by shooting photons.  <a href="#a92698ce57d3517d9b281653dcf83da18">More...</a><br/></td></tr>
<tr class="separator:a92698ce57d3517d9b281653dcf83da18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d8564b67da04c55ecb4f0b882a8f96"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac2d8564b67da04c55ecb4f0b882a8f96">shoot</a></td></tr>
<tr class="memdesc:ac2d8564b67da04c55ecb4f0b882a8f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shoot photons into a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a>.  <a href="#ac2d8564b67da04c55ecb4f0b882a8f96">More...</a><br/></td></tr>
<tr class="separator:ac2d8564b67da04c55ecb4f0b882a8f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131c41320f9504616ab161aec99b1f59"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a131c41320f9504616ab161aec99b1f59">drawKImage</a></td></tr>
<tr class="memdesc:a131c41320f9504616ab161aec99b1f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the k-space (complex) Image of the object, with bounds optionally set by input Image instance.  <a href="#a131c41320f9504616ab161aec99b1f59">More...</a><br/></td></tr>
<tr class="separator:a131c41320f9504616ab161aec99b1f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27025c7d3f06e196017892ebb4f77909"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a27025c7d3f06e196017892ebb4f77909">__eq__</a></td></tr>
<tr class="separator:a27025c7d3f06e196017892ebb4f77909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d05278b83ff4e824b92ebf3e7d8f4c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a78d05278b83ff4e824b92ebf3e7d8f4c">__ne__</a></td></tr>
<tr class="separator:a78d05278b83ff4e824b92ebf3e7d8f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5305c6bc48093edecaca7e1afbd4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a0df5305c6bc48093edecaca7e1afbd4f">__hash__</a></td></tr>
<tr class="separator:a0df5305c6bc48093edecaca7e1afbd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adb96a86d456346183b76f4509d11c34b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#adb96a86d456346183b76f4509d11c34b">flux</a></td></tr>
<tr class="separator:adb96a86d456346183b76f4509d11c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all GalSim classes that represent some kind of surface brightness profile. </p>
<p>A <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> is not intended to be constructed directly. Normally, you would use whatever derived class is appropriate for the surface brightness profile you want: </p>
<pre class="fragment">&gt;&gt;&gt; gal = galsim.Sersic(n=4, half_light_radius=4.3)
&gt;&gt;&gt; psf = galsim.Moffat(beta=3, fwhm=2.85)
&gt;&gt;&gt; conv = galsim.Convolve([gal,psf])
</pre><p>All of these classes are subclasses of <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>, so you should see those docstrings for more details about how to construct the various profiles. Here we discuss attributes and methods that are common to all GSObjects.</p>
<p>GSObjects are always defined in sky coordinates. So all sizes and other linear dimensions should be in terms of some kind of units on the sky, arcsec for instance. Only later (when they are drawn) is the connection to pixel coordinates established via a pixel scale or WCS. (See the documentation for galsim.BaseWCS for more details about how to specify various kinds of world coordinate systems more complicated than a simple pixel scale.)</p>
<p>For instance, if you eventually draw onto an image that has a pixel scale of 0.2 arcsec/pixel, then the normal thing to do would be to define your surface brightness profiles in terms of arcsec and then draw with <code>pixel_scale=0.2</code>. However, while arcsec are the usual choice of units for the sky coordinates, if you wanted, you could instead define the sizes of all your galaxies and PSFs in terms of radians and then use <code>pixel_scale=0.2/206265</code> when you draw them.</p>
<h2>Transforming Methods </h2>
<p>The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> class uses an "immutable" design[1], so all methods that would potentially modify the object actually return a new object instead. This uses pointers and such behind the scenes, so it all happens efficiently, but it makes using the objects a bit simpler, since you don't need to worry about some function changing your object behind your back.</p>
<p>In all cases below, we just give an example usage. See the docstrings for the methods for more details about how to use them. </p>
<pre class="fragment">&gt;&gt;&gt; obj = obj.shear(shear)      # Apply a shear to the object.
&gt;&gt;&gt; obj = obj.dilate(scale)     # Apply a flux-preserving dilation.
&gt;&gt;&gt; obj = obj.magnify(mu)       # Apply a surface-brightness-preserving magnification.
&gt;&gt;&gt; obj = obj.rotate(theta)     # Apply a rotation.
&gt;&gt;&gt; obj = obj.shift(dx,dy)      # Shft the object in real space.
&gt;&gt;&gt; obj = obj.transform(dudx,dudy,dvdx,dvdy)    # Apply a general jacobian transformation.
&gt;&gt;&gt; obj = obj.lens(g1,g2,mu)    # Apply both a lensing shear and magnification.
&gt;&gt;&gt; obj = obj.withFlux(flux)    # Set a new flux value.
&gt;&gt;&gt; obj = obj * ratio           # Scale the surface brightness profile by some factor.
</pre><h2>Access Methods </h2>
<p>There are some access methods and properties that are available for all GSObjects. Again, see the docstrings for each method for more details. </p>
<pre class="fragment">&gt;&gt;&gt; obj.flux
&gt;&gt;&gt; obj.centroid
&gt;&gt;&gt; obj.nyquist_scale
&gt;&gt;&gt; obj.stepk
&gt;&gt;&gt; obj.maxk
&gt;&gt;&gt; obj.has_hard_edges
&gt;&gt;&gt; obj.is_axisymmetric
&gt;&gt;&gt; obj.is_analytic_x
&gt;&gt;&gt; obj.is_analytic_k
&gt;&gt;&gt; obj.xValue(x,y) or obj.xValue(pos)
&gt;&gt;&gt; obj.kValue(kx,ky) os obj.kValue(kpos)
</pre><p>Most subclasses have additional methods that are available for values that are particular to that specific surface brightness profile. e.g. <code>sigma = gauss.getSigma()</code>. However, note that class-specific methods are not available after performing one of the above transforming operations. </p>
<pre class="fragment">&gt;&gt;&gt; gal = galsim.Gaussian(sigma=5)
&gt;&gt;&gt; gal = gal.shear(g1=0.2, g2=0.05)
&gt;&gt;&gt; sigma = gal.getSigma()              # This will raise an exception.
</pre><p>It is however possible to access the original object that was transformed via the <code>original</code> attribute. </p>
<pre class="fragment">&gt;&gt;&gt; sigma = gal.original.getSigma()     # This works.
</pre><p>No matter how many transformations are performed, the <code>original</code> attribute will contain the <em>original</em> object (not necessarily the most recent ancestor).</p>
<h2>Drawing Methods </h2>
<p>The main thing to do with a <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> once you have built it is to draw it onto an image. There are two methods that do this. In both cases, there are lots of optional parameters. See the docstrings for these methods for more details. </p>
<pre class="fragment">&gt;&gt;&gt; image = obj.drawImage(...)
&gt;&gt;&gt; kimage = obj.drawKImage(...)
</pre><h2>Attributes </h2>
<p>There two attributes that may be available for a <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. </p>
<pre class="fragment">original    This was mentioned above as a way to access the original object that has
            been transformed by one of the transforming methods.

noise       Some types, like RealGalaxy, set this attribute to be the intrinsic noise that
            is already inherent in the profile and will thus be present when you draw the
            object.  The noise is propagated correctly through the various transforming
            methods, as well as convolutions and flux rescalings.  Note that the `noise`
            attribute can be set directly by users even for GSObjects that do not naturally
            have one. The typical use for this attribute is to use it to whiten the noise in
            the image after drawing.  See CorrelatedNoise for more details.
</pre><h2><a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> </h2>
<p>All <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> classes take an optional <code>gsparams</code> argument, so we document that feature here. For all documentation about the specific derived classes, please see the docstring for each one individually.</p>
<p>The <code>gsparams</code> argument can be used to specify various numbers that govern the tradeoff between accuracy and speed for the calculations made in drawing a <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. The numbers are encapsulated in a class called <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a>, and the user should make careful choices whenever they opt to deviate from the defaults. For more details about the parameters and their default values, please see the docstring of the <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> class (e.g. type <code>help(<a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams</a>)</code>).</p>
<p>For example, let's say you want to do something that requires an FFT larger than 4096 x 4096 (and you have enough memory to handle it!). Then you can create a new <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> object with a larger <code>maximum_fft_size</code> and pass that to your <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> on construction: </p>
<pre class="fragment">&gt;&gt;&gt; gal = galsim.Sersic(n=4, half_light_radius=4.3)
&gt;&gt;&gt; psf = galsim.Moffat(beta=3, fwhm=2.85)
&gt;&gt;&gt; conv = galsim.Convolve([gal,psf])
&gt;&gt;&gt; im = galsim.Image(1000,1000, scale=0.05)        # Note the very small pixel scale!
&gt;&gt;&gt; im = conv.drawImage(image=im)                   # This uses the default GSParams.
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "galsim/base.py", line 1236, in drawImage
    image.added_flux = prof._sbp.draw(imview.image)
RuntimeError: SB Error: fourierDraw() requires an FFT that is too large, 6144
If you can handle the large FFT, you may update gsparams.maximum_fft_size.
&gt;&gt;&gt; big_fft_params = galsim.GSParams(maximum_fft_size=10240)
&gt;&gt;&gt; conv = galsim.Convolve([gal,psf],gsparams=big_fft_params)
&gt;&gt;&gt; im = conv.drawImage(image=im)                   # Now it works (but is slow!)
&gt;&gt;&gt; im.write('high_res_sersic.fits')
</pre><p>Note that for compound objects in <a class="el" href="compound_8py.html" title="Some compound GSObject classes that contain other GSObject instances: ">compound.py</a>, like Convolution or Sum, not all <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> can be changed when the compound object is created. In the example given here, it is possible to change parameters related to the drawing, but not the Fourier space parameters for the components that go into the Convolution. To get better sampling in Fourier space, for example, the <code>gal</code> and/or <code>psf</code> should be created with <code>gsparams</code> that have a non-default value of <code>folding_threshold</code>. This statement applies to the threshold and accuracy parameters. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a48338aff4532994d9e3b3b9c01ec7530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sbp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9e318ee4a675c83a63472df5ba826a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ce5e57bb992fcd021473c287e1f09e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__div__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to obj * (1/other) </p>

</div>
</div>
<a class="anchor" id="a27025c7d3f06e196017892ebb4f77909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0df5305c6bc48093edecaca7e1afbd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__hash__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a045ae78d7b08052ee9fe3a4c242c01c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale the flux of the object by the given factor. </p>
<p>obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount.</p>
<p>You can also multiply by an SED, which will create a ChromaticObject where the SED acts like a wavelength-dependent <code>flux_ratio</code>. </p>

</div>
</div>
<a class="anchor" id="a78d05278b83ff4e824b92ebf3e7d8f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a405a8ab440a5f45ed928056b912711b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__neg__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ada028fbaa5f466eb539ab8216417bc3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to obj * other. </p>

</div>
</div>
<a class="anchor" id="ae01cefd5df227baeb21f981edd5cb0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4cf633d1aee3ef1739a5377436afc76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.calculateFWHM </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the full-width half-maximum (FWHM) of the object. </p>
<p>If the profile has a fwhm attribute, it will just return that, but in the general case, we draw the profile and estimate the FWHM directly.</p>
<p>As with calculateHLR and calculateMomentRadius, this function optionally takes size and scale values to use for the image drawing. The default is to use the the Nyquist scale for the pixel scale and let drawImage choose a size for the stamp that will enclose at least 99.5% of the flux. These were found to produce results accurate to well below one percent on our internal tests, so it is unlikely that you will want to adjust them for accuracy. However, using a smaller size than default could help speed up the calculation, since the default is usually much larger than is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the full-width half-maximum in physical units </dd></dl>

</div>
</div>
<a class="anchor" id="a52e1e223bae1d88d24f4f7808cd2a8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.calculateHLR </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_frac</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the half-light radius of the object. </p>
<p>If the profile has a half_light_radius attribute, it will just return that, but in the general case, we draw the profile and estimate the half-light radius directly.</p>
<p>This function (by default at least) is only accurate to a few percent, typically. Possibly worse depending on the profile being measured. If you care about a high precision estimate of the half-light radius, the accuracy can be improved using the optional parameter scale to change the pixel scale used to draw the profile.</p>
<p>The default scale is half the Nyquist scale, which were found to produce results accurate to a few percent on our internal tests. Using a smaller scale will be more accurate at the expense of speed.</p>
<p>In addition, you can optionally specify the size of the image to draw. The default size is None, which means drawImage will choose a size designed to contain around 99.5% of the flux. This is overkill for this calculation, so choosing a smaller size than this may speed up this calculation somewhat.</p>
<p>Also, while the name of this function refers to the half-light radius, in fact it can also calculate radii that enclose other fractions of the light, according to the parameter <code>flux_frac</code>. E.g. for r90, you would set flux_frac=0.90.</p>
<p>The default scale should usually be acceptable for things like testing that a galaxy has a reasonable resolution, but they should not be trusted for very fine grain discriminations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: 0.5 * self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid] </td></tr>
    <tr><td class="paramname">flux_frac</td><td>The fraction of light to be enclosed by the returned radius. [default: 0.5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the half-light radius in physical units </dd></dl>

</div>
</div>
<a class="anchor" id="a8db2e52914acb931e42713fbce263ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.calculateMomentRadius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'det'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an estimate of the radius based on unweighted second moments. </p>
<p>The second moments are defined as:</p>
<p>Q_ij = int( I(x,y) i j dx dy ) / int( I(x,y) dx dy ) where i,j may be either x or y.</p>
<p>If I(x,y) is a Gaussian, then T = Tr(Q) = Qxx + Qyy = 2 sigma^2. Thus, one reasonable choice for a "radius" for an arbitrary profile is sqrt(T/2).</p>
<p>In addition, det(Q) = sigma^4. So another choice for an arbitrary profile is det(Q)^1/4.</p>
<p>This routine can return either of these measures according to the value of the <code>rtype</code> parameter. <code>rtype='trace'</code> will cause it to return sqrt(T/2). <code>rtype='det'</code> will cause it to return det(Q)^1/4. And <code>rtype='both'</code> will return a tuple with both values.</p>
<p>Note that for the special case of a Gaussian profile, no calculation is necessary, and the <code>sigma</code> attribute will be used in both cases. In the limit as scale-&gt;0, this function will return the same value, but because finite pixels are drawn, the results will not be precisely equal for real use cases. The approximation being made is that the integral of I(x,y) i j dx dy over each pixel can be approximated as int(I(x,y) dx dy) * i_center * j_center.</p>
<p>This function (by default at least) is only accurate to a few percent, typically. Possibly worse depending on the profile being measured. If you care about a high precision estimate of the radius, the accuracy can be improved using the optional parameters size and scale to change the size and pixel scale used to draw the profile.</p>
<p>The default is to use the the Nyquist scale for the pixel scale and let drawImage choose a size for the stamp that will enclose at least 99.5% of the flux. These were found to produce results accurate to a few percent on our internal tests. Using a smaller scale and larger size will be more accurate at the expense of speed.</p>
<p>The default parameters should usually be acceptable for things like testing that a galaxy has a reasonable resolution, but they should not be trusted for very fine grain discriminations. For a more accurate estimate, see <a class="el" href="namespacegalsim_1_1hsm.html#a609965656c1fb90e664a6439312ac1fc" title="Measure adaptive moments of an object. ">galsim.hsm.FindAdaptiveMom</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid] </td></tr>
    <tr><td class="paramname">rtype</td><td>There are three options for this parameter:<ul>
<li>'trace' means return sqrt(T/2)</li>
<li>'det' means return det(Q)^1/4</li>
<li>'both' means return both: (sqrt(T/2), det(Q)^1/4) [default: 'det']</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the radius in physical units (or both estimates if rtype == 'both') </dd></dl>

</div>
</div>
<a class="anchor" id="a3428ec61c500c299eaf83185794d0fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>. </p>

</div>
</div>
<a class="anchor" id="ad3bdbbb228af6bee2c839b6860afa8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.deinterpolated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa26483093b11e5a0264ee3e0f3ad5acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.dilate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>See <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a68ebb301de472bdd366210422ea32f7d" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> and <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for versions that preserve surface brightness, and thus changes the flux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The linear rescaling factor to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dilated object. </dd></dl>

</div>
</div>
<a class="anchor" id="a71058b4578a2a1ff04bbe10d58be4d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.dimensionless </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aad5fc663b598862f9a003955eee8e3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw this profile into an Image by computing the k-space image and performing an FFT. </p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p>
<pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawFFT</code> represents the profile sampled at the center of each pixel and then multiplied by the pixel area. That is, the profile is NOT integrated over the area of the pixel. This is equivalent to method='no_pixel' in drawImage. If you want to render a profile integrated over the pixel, you can convolve with a Pixel first and draw that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d2cee1943d989834de0823f9d581218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawFFT_finish </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kimage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper routine for drawFFT that finishes the calculation, based on the drawn k-space image. </p>
<p>It applies the Fourier transform to <code>kimage</code> and adds the result to <code>image</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. </td></tr>
    <tr><td class="paramname">kimage</td><td>The k-space Image where the object was drawn. </td></tr>
    <tr><td class="paramname">wrap_size</td><td>The size of the region to wrap kimage, which must be either the same size as kimage or smaller. </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cdaeaa677f2cfcc7e33374dd8c3fd68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawFFT_makeKImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper routine for drawFFT that just makes the (blank) k-space image onto which the profile will be drawn. </p>
<p>This can be useful if you want to break up the calculation into parts for extra efficiency. E.g. save the k-space image of the PSF so drawing many models of the galaxy with the given PSF profile can avoid drawing the PSF each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(kimage, wrap_size), where wrap_size is either the size of kimage or smaller if the result should be wrapped before doing the inverse fft. </dd></dl>

</div>
</div>
<a class="anchor" id="a67c2e0b2207854148cd060957808076c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exptime</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_true_center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sensor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>surface_ops</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_subsample</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxN</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>save_photons</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws an Image of the object. </p>
<p>The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> method is used to draw an Image of the current object using one of several possible rendering methods (see below). It can create a new Image or can draw onto an existing one if provided by the <code>image</code> parameter. If the <code>image</code> is given, you can also optionally add to the given Image if <code>add_to_image = True</code>, but the default is to replace the current contents with new values.</p>
<h2>Providing an input image </h2>
<p>Note that if you provide an <code>image</code> parameter, it is the image onto which the profile will be drawn. The provided image <em>will be modified</em>. A reference to the same image is also returned to provide a parallel return behavior to when <code>image</code> is <code>None</code> (described above).</p>
<p>This option is useful in practice because you may want to construct the image first and then draw onto it, perhaps multiple times. For example, you might be drawing onto a subimage of a larger image. Or you may want to draw different components of a complex profile separately. In this case, the returned value is typically ignored. For example: </p>
<pre class="fragment">    &gt;&gt;&gt; im1 = bulge.drawImage()
    &gt;&gt;&gt; im2 = disk.drawImage(image=im1, add_to_image=True)
    &gt;&gt;&gt; assert im1 is im2

    &gt;&gt;&gt; full_image = galsim.Image(2048, 2048, scale=pixel_scale)
    &gt;&gt;&gt; b = galsim.BoundsI(x-32, x+32, y-32, y+32)
    &gt;&gt;&gt; stamp = obj.drawImage(image = full_image[b])
    &gt;&gt;&gt; assert (stamp.array == full_image[b].array).all()
</pre><h2>Letting drawImage create the image for you </h2>
<p>If <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> will be creating the image from scratch for you, then there are several ways to control the size of the new image. If the <code>nx</code> and <code>ny</code> keywords are present, then an image with these numbers of pixels on a side will be created. Similarly, if the <code>bounds</code> keyword is present, then an image with the specified bounds will be created. Note that it is an error to provide an existing Image when also specifying <code>nx</code>, <code>ny</code>, or <code>bounds</code>. In the absence of <code>nx</code>, <code>ny</code>, and <code>bounds</code>, drawImage will decide a good size to use based on the size of the object being drawn. Basically, it will try to use an area large enough to include at least 99.5% of the flux. (Note: the value 0.995 is really <code>1 - folding_threshold</code>. You can change the value of <code>folding_threshold</code> for any object via <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a>. See <code>help(GSParams)</code> for more details.) You can set the pixel scale of the constructed image with the <code>scale</code> parameter, or set a WCS function with <code>wcs</code>. If you do not provide either <code>scale</code> or <code>wcs</code>, then <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> will default to using the Nyquist scale for the current object. You can also set the data type used in the new Image with the <code>dtype</code> parameter that has the same options as for the Image constructor.</p>
<h2>The drawing "method" </h2>
<p>There are several different possible methods <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> can use for rendering the image. This is set by the <code>method</code> parameter. The options are: </p>
<pre class="fragment">'auto'      This is the default, which will normally be equivalent to 'fft'.  However,
            if the object being rendered is simple (no convolution) and has hard edges
            (e.g. a Box or a truncated Moffat or Sersic), then it will switch to
            'real_space', since that is often both faster and more accurate in these
            cases (due to ringing in Fourier space).

'fft'       The integration of the light within each pixel is mathematically equivalent
            to convolving by the pixel profile (a Pixel object) and sampling the result
            at the centers of the pixels.  This method will do that convolution using
            a discrete Fourier transform.  Furthermore, if the object (or any component
            of it) has been transformed via shear(), dilate(), etc., then these
            transformations are done in Fourier space as well.

'real_space'  This uses direct integrals (using the Gauss-Kronrod-Patterson algorithm)
            in real space for the integration over the pixel response.  It is usually
            slower than the 'fft' method, but if the profile has hard edges that cause
            ringing in Fourier space, it can be faster and/or more accurate.  If you
            use 'real_space' with something that is already a Convolution, then this
            will revert to 'fft', since the double convolution that is required to also
            handle the pixel response is far too slow to be practical using real-space
            integrals.

'phot'      This uses a technique called photon shooting to render the image.
            Essentially, the object profile is taken as a probability distribution
            from which a finite number of photons are "shot" onto the image.  Each
            photon's flux gets added to whichever pixel the photon hits.  This process
            automatically accounts for the integration of the light over the pixel
            area, since all photons that hit any part of the pixel are counted.
            Convolutions and transformations are simple geometric processes in this
            framework.  However, there are two caveats with this method: (1) the
            resulting image will have Poisson noise from the finite number of photons,
            and (2) it is not available for all object types (notably anything that
            includes a Deconvolution).

'no_pixel'  Instead of integrating over the pixels, this method will sample the profile
            at the centers of the pixels and multiply by the pixel area.  If there is
            a convolution involved, the choice of whether this will use an FFT or
            real-space calculation is governed by the `real_space` parameter of the
            Convolution class.  This method is the appropriate choice if you are using
            a PSF that already includes a convolution by the pixel response.  For
            example, if you are using a PSF from an observed image of a star, then it
            has already been convolved by the pixel, so you would not want to do so
            again.  Note: The multiplication by the pixel area gets the flux
            normalization right for the above use case.  cf. `method = 'sb'`.

'sb'        This is a lot like 'no_pixel', except that the image values will simply be
            the sampled object profile's surface brightness, not multiplied by the
            pixel area.  This does not correspond to any real observing scenario, but
            it could be useful if you want to view the surface brightness profile of an
            object directly, without including the pixel integration.
</pre><p>The 'phot' method has a few extra parameters that adjust how it functions. The total number of photons to shoot is normally calculated from the object's flux. This flux is taken to be given in photons/cm^2/s, so for most simple profiles, this times area * exptime will equal the number of photons shot. (See the discussion in Rowe et al, 2015, for why this might be modified for InterpolatedImage and related profiles.) However, you can manually set a different number of photons with <code>n_photons</code>. You can also set <code>max_extra_noise</code> to tell <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> to use fewer photons than normal (and so is faster) such that no more than that much extra noise is added to any pixel. This is particularly useful if you will be subsequently adding sky noise, and you can thus tolerate more noise than the normal number of photons would give you, since using fewer photons is of course faster. Finally, the default behavior is to have the total flux vary as a Poisson random variate, which is normally appropriate with photon shooting. But you can turn this off with <code>poisson_flux=False</code>. It also defaults to False if you set an explicit value for <code>n_photons</code>.</p>
<p>Given the periodicity implicit in the use of FFTs, there can occasionally be artifacts due to wrapping at the edges, particularly for objects that are quite extended (e.g., due to the nature of the radial profile). See <code>help(<a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams</a>)</code> for parameters that you can use to reduce the level of these artifacts, in particular <code>folding_threshold</code> may be helpful if you see such artifacts in your images.</p>
<h2>Setting the offset </h2>
<p>The object will by default be drawn with its nominal center at the center location of the image. There is thus a qualitative difference in the appearance of the rendered profile when drawn on even- and odd-sized images. For a profile with a maximum at (0,0), this maximum will fall in the central pixel of an odd-sized image, but in the corner of the four central pixels of an even-sized image. There are two parameters that can affect this behavior. If you want the nominal center to always fall at the center of a pixel, you can use <code>use_true_center=False</code>. This will put the object's center at the position <code>image.center</code> which is an integer pixel value, and is not the true center of an even-sized image. You can also arbitrarily offset the profile from the image center with the <code>offset</code> parameter to handle any sub-pixel dithering you want.</p>
<h2>Setting the overall normalization </h2>
<p>Normally, the flux of the object should be equal to the sum of all the pixel values in the image, less some small amount of flux that may fall off the edge of the image (assuming you don't use <code>method='sb'</code>). However, you may optionally set a <code>gain</code> value, which converts between photons and ADU (so-called analog-to-digital units), the units of the pixel values in real images. Normally, the gain of a CCD is in electrons/ADU, but in GalSim, we fold the quantum efficiency into the gain as well, so the units are photons/ADU.</p>
<p>Another caveat is that, technically, flux is really in units of photons/cm^2/s, not photons. So if you want, you can keep track of this properly and provide an <code>area</code> and <code>exposure</code> time here. This detail is more important with chromatic objects where the SED is typically given in erg/cm^2/s/nm, so the exposure time and area are important details. With achromatic objects however, it is often more convenient to ignore these details and just consider the flux to be the total number of photons for this exposure, in which case, you would leave the area and exptime parameters at their default value of 1.</p>
<p>On return, the image will have an attribute <code>added_flux</code>, which will be set to the total flux added to the image. This may be useful as a sanity check that you have provided a large enough image to catch most of the flux. For example: </p>
<pre class="fragment">&gt;&gt;&gt; obj.drawImage(image)
&gt;&gt;&gt; assert image.added_flux &gt; 0.99 * obj.flux
</pre><p>The appropriate threshold will depend on your particular application, including what kind of profile the object has, how big your image is relative to the size of your object, whether you are keeping <code>poisson_flux=True</code>, etc.</p>
<p>The following code snippet illustrates how <code>gain</code>, <code>exptime</code>, <code>area</code>, and <code>method</code> can all influence the relationship between the <code>flux</code> attribute of a <code><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a></code> and both the pixel values and <code>.added_flux</code> attribute of an <code>Image</code> drawn with <code><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a></code>: </p>
<pre class="fragment">&gt;&gt;&gt; obj = galsim.Gaussian(fwhm=1)
&gt;&gt;&gt; obj.flux
1.0
&gt;&gt;&gt; im = obj.drawImage()
&gt;&gt;&gt; im.added_flux
0.9999630988657515
&gt;&gt;&gt; im.array.sum()
0.99996305
&gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10)
&gt;&gt;&gt; im.added_flux
0.9999630988657525
&gt;&gt;&gt; im.array.sum()
99.996315
&gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, method='sb', scale=0.5, nx=10, ny=10)
&gt;&gt;&gt; im.added_flux
0.9999973790505298
&gt;&gt;&gt; im.array.sum()
399.9989
&gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, gain=2)
&gt;&gt;&gt; im.added_flux
0.9999630988657525
&gt;&gt;&gt; im.array.sum()
49.998158
</pre><h2>Using a non-trivial sensor </h2>
<p>Normally the sensor is modeled as an array of pixels where any photon that hits a given pixel is accumulated into that pixel. The final pixel value then just reflects the total number of pixels that hit each sensor. However, real sensors do not (quite) work this way.</p>
<p>In real CCDs, the photons travel some distance into the silicon before converting to electrons. Then the electrons diffuse laterally some amount as they are pulled by the electric field toward the substrate. Finally, previous electrons that have already been deposited will repel subsequent electrons, both slowing down their descent, leading to more diffusion, and pushing them laterally toward neighboring pixels, which is called the brighter-fatter effect.</p>
<p>Users interested in modeling this kind of effect can supply a <code>sensor</code> object to use for the accumulation step. See <code>SiliconSensor</code> in <a class="el" href="sensor_8py.html" title="The Sensor classes implement the process of turning a set of photons incident at the surface of the d...">sensor.py</a> for a class that models silicon-based CCD sensors.</p>
<p>Some related effects may need to be done to the photons at the surface layer before being passed into the sensor object. For instance, the photons may need to be given appropriate incidence angles according to the optics of the telescope (since this matters for where the photons are converted to electrons). You may also need to give the photons wavelengths according to the SED of the object. Such steps are specified in a <code>surface_ops</code> parameter, which should be a list of any such operations you wish to perform on the photon array before passing them to the sensor. See <code>FRatioAngles</code> and <code>WavelengthSampler</code> in photon_array.py for two examples of such surface operators.</p>
<p>Since the sensor deals with photons, it is most natural to use this feature in conjunction with photon shooting (<code>method='phot'</code>). However, it is allowed with FFT methods too. But there is a caveat one should be aware of in this case. The FFT drawing is used to produce an intermediate image, which is then converted to a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> using the factory function <code>PhotonArray.makeFromImage</code>. This assigns photon positions randomly within each pixel where they were drawn, which isn't always a particularly good approximation.</p>
<p>To improve this behavior, the intermediate image is drawn with smaller pixels than the target image, so the photons are given positions closer to their true locations. The amount of subsampling is controlled by the <code>n_subsample</code> parameter, which defaults to 3. Larger values will be more accurate at the expense of larger FFTs (i.e. slower and using more memory).</p>
<h2>Initialization parameters </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the image on which to draw the profile. If <code>image</code> is None, then an automatically-sized Image will be created. If <code>image</code> is given, but its bounds are undefined (e.g. if it was constructed with <code>image = galsim.Image()</code>), then it will be resized appropriately based on the profile's size [default: None]. </td></tr>
    <tr><td class="paramname">nx</td><td>If provided and <code>image</code> is None, use to set the x-direction size of the image. Must be accompanied by <code>ny</code>. </td></tr>
    <tr><td class="paramname">ny</td><td>If provided and <code>image</code> is None, use to set the y-direction size of the image. Must be accompanied by <code>nx</code>. </td></tr>
    <tr><td class="paramname">bounds</td><td>If provided and <code>image</code> is None, use to set the bounds of the image. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the image. If <code>scale</code> is None and <code>image</code> is given, then take the provided image's pixel scale. If <code>scale</code> is None and <code>image</code> is None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>image</code>), then use the Nyquist scale. If <code>scale &gt; 0</code> and <code>image</code> is given, then override <code>image.scale</code> with the value given as a keyword. [default: None] </td></tr>
    <tr><td class="paramname">wcs</td><td>If provided, use this as the wcs for the image (possibly overriding any existing <code>image.wcs</code>). At most one of <code>scale</code> or <code>wcs</code> may be provided. [default: None] </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type to use for an automatically constructed image. Only valid if <code>image</code> is None. [default: None, which means to use numpy.float32] </td></tr>
    <tr><td class="paramname">method</td><td>Which method to use for rendering the image. See discussion above for the various options and what they do. [default: 'auto'] </td></tr>
    <tr><td class="paramname">area</td><td>Collecting area of telescope in cm^2. [default: 1.] </td></tr>
    <tr><td class="paramname">exptime</td><td>Exposure time in s. [default: 1.] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. Note: This requires that <code>image</code> be provided and that it have defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">use_true_center</td><td>Normally, the profile is drawn to be centered at the true center of the image (using the property image.true_center). If you would rather use the integer center (given by image.center), set this to <code>False</code>. [default: True] </td></tr>
    <tr><td class="paramname">offset</td><td>The location in pixel coordinates at which to center the profile being drawn relative to the center of the image (either the true center if <code>use_true_center=True</code> or nominal center if <code>use_true_center=False</code>). [default: None] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use for photon shooting. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel when photon shooting. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, then you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. [default: 0.] </td></tr>
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples when photon shooting. [default: True, unless <code>n_photons</code> is given, in which case the default is False] </td></tr>
    <tr><td class="paramname">sensor</td><td>An optional Sensor instance, which will be used to accumulate the photons onto the image. [default: None] </td></tr>
    <tr><td class="paramname">surface_ops</td><td>A list of operators that can modify the photon array that will be applied in order before accumulating the photons on the sensor. [default: ()] </td></tr>
    <tr><td class="paramname">n_subsample</td><td>The number of sub-pixels per final pixel to use for fft drawing when using a sensor. The sensor step needs to know the sub-pixel positions of the photons, which is lost in the fft method. So using smaller pixels for the fft step keeps some of that information, making the assumption of uniform flux per pixel less bad of an approximation. [default: 3] </td></tr>
    <tr><td class="paramname">maxN</td><td>Sets the maximum number of photons that will be added to the image at a time. (Memory requirements are proportional to this number.) [default: None, which means no limit] </td></tr>
    <tr><td class="paramname">save_photons</td><td>If True, save the <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> as <code>image.photons</code>. Only valid if method is 'phot' or sensor is not None. [default: False] </td></tr>
    <tr><td class="paramname">setup_only</td><td>Don't actually draw anything on the image. Just make sure the image is set up correctly. This is used internally by GalSim, but there may be cases where the user will want the same functionality. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the drawn Image. </dd></dl>

</div>
</div>
<a class="anchor" id="a131c41320f9504616ab161aec99b1f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawKImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recenter</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dk</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>re</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the k-space (complex) Image of the object, with bounds optionally set by input Image instance. </p>
<p>Normalization is always such that image(0,0) = flux. Unlike the real-space <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> function, the (0,0) point will always be one of the actual pixel values. For even-sized images, it will be 1/2 pixel above and to the right of the true center of the image.</p>
<p>Another difference from <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a67c2e0b2207854148cd060957808076c" title="Draws an Image of the object. ">drawImage()</a> is that a wcs other than a simple pixel scale is not allowed. There is no <code>wcs</code> parameter here, and if the images have a non-trivial wcs (and you don't override it with the <code>scale</code> parameter), a TypeError will be raised.</p>
<p>Also, there is no convolution by a pixel. This is just a direct image of the Fourier transform of the surface brightness profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the Image onto which to draw the k-space image. If <code>image</code> is None, then an automatically-sized image will be created. If <code>image</code> is given, but its bounds are undefined, then it will be resized appropriately based on the profile's size. [default: None] </td></tr>
    <tr><td class="paramname">nx</td><td>If provided and <code>image</code> is None, use to set the x-direction size of the image. Must be accompanied by <code>ny</code>. </td></tr>
    <tr><td class="paramname">ny</td><td>If provided and <code>image</code> is None, use to set the y-direction size of the image. Must be accompanied by <code>nx</code>. </td></tr>
    <tr><td class="paramname">bounds</td><td>If provided and <code>image</code> is None, use to set the bounds of the image. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale, dk, for the images. If <code>scale</code> is None and <code>image</code> is given, then take the provided images' pixel scale (which must be equal). If <code>scale</code> is None and <code>image</code> is None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>image</code>), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. Note: This requires that <code>image</code> be provided and that it has defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">recenter</td><td>Whether to recenter the image to put k = 0 at the center (True) or to trust the provided bounds (False). [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Image instance (created if necessary) </dd></dl>

</div>
</div>
<a class="anchor" id="a92698ce57d3517d9b281653dcf83da18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawPhot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sensor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>surface_ops</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxN</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orig_center</em> = <code>galsim.PositionI(0,0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw this profile into an Image by shooting photons. </p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p>
<pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawPhot</code> represents the profile integrated over the area of each pixel. This is equivalent to convolving the profile by a square <code>Pixel</code> profile and sampling the value at the center of each pixel, although this happens automatically by the shooting algorithm, so you do not need to manually convolve by a Pixel as you would for <code>drawReal</code> or <code>drawFFT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1.] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. [default: False] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use for photon shooting. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel when photon shooting. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, then you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. [default: 0.] </td></tr>
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples when photon shooting. [default: True, unless <code>n_photons</code> is given, in which case the default is False] </td></tr>
    <tr><td class="paramname">sensor</td><td>An optional Sensor instance, which will be used to accumulate the photons onto the image. [default: None] </td></tr>
    <tr><td class="paramname">surface_ops</td><td>A list of operators that can modify the photon array that will be applied in order before accumulating the photons on the sensor. [default: ()] </td></tr>
    <tr><td class="paramname">maxN</td><td>Sets the maximum number of photons that will be added to the image at a time. (Memory requirements are proportional to this number.) [default: None, which means no limit] </td></tr>
    <tr><td class="paramname">orig_center</td><td>The position of the image center in the original image coordinates. [default: (0,0)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux of photons that landed inside the image bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e0c8f475eea12dec5b66dfb140f177e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.drawReal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw this profile into an Image by direct evaluation at the location of each pixel. </p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p>
<pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawReal</code> represents the profile sampled at the center of each pixel and then multiplied by the pixel area. That is, the profile is NOT integrated over the area of the pixel. This is equivalent to method='no_pixel' in drawImage. If you want to render a profile integrated over the pixel, you can convolve with a Pixel first and draw that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a2502a92a52f1d58cdfc55b2d1cd37617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.evaluateAtWavelength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return profile at a given wavelength. </p>
<p>For <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances, this is just <code>self</code>. This allows <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances to be duck-typed as ChromaticObject instances. </p>

</div>
</div>
<a class="anchor" id="a68ebb301de472bdd366210422ea32f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>This doesn't correspond to either of the normal operations one would typically want to do to a galaxy. The functions <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aa26483093b11e5a0264ee3e0f3ad5acf" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> and <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> are the more typical usage. But this function is conceptually simple. It rescales the linear dimension of the profile, while preserving surface brightness. As a result, the flux will necessarily change as well.</p>
<p>See <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aa26483093b11e5a0264ee3e0f3ad5acf" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for a version that applies a scale factor to the area while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The factor by which to scale the linear dimension of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expanded object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf1843da478c2369a35cfbfdbccaa96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1afd2e68c557ef14ba8b6770e027dc62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.getFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37480bc89b03769478f673b6e854e968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.getGoodImageSize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pixel_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a good size to use for drawing this profile. </p>
<p>The size will be large enough to cover most of the flux of the object. Specifically, at least (1-gsparams.folding_threshold) (i.e. 99.5% by default) of the flux should fall in the image.</p>
<p>Also, the returned size is always an even number, which is usually desired in practice. Of course, if you prefer an odd-sized image, you can add 1 to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixel_scale</td><td>The desired pixel scale of the image to be built.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N, a good (linear) size of an image on which to draw this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea5c4faf1ec76d936de2e88330396ce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.getGSParams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dfb86711851c112d5e303ba4f392755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.getNegativeFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a992c51c7af6fcaa104c9e3e3b8df0e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.getPositiveFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2eb0162c8cfad9acc8d178dc6e12fd4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.gsparams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d107ccdab66e3bcd65067c2c6ca348e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.has_hard_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain. </p>

</div>
</div>
<a class="anchor" id="ae7449e6df8bf5cff587db3817333ca74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.hasHardEdges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8c76de460e6e8a492c40642aa718956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.interpolated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a11539f6fa17581075b119536e65e842f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.is_analytic_k </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a79556f8e9ed661b1b3f1ce5cc61d425a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.is_analytic_x </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a454f827d264c257582424ccac0c17a71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.is_axisymmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wthether the profile is axially symmetric; affects efficiency of evaluation. </p>

</div>
</div>
<a class="anchor" id="acf0399146659893722e457d996c61cd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.isAnalyticK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af08fda46012fb257906bab49ed084a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.isAnalyticX </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52e69481a5c6b0babaa907056b067f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.isAxisymmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a924e2d85a44389099bd8e74e591017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.kValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in k space. </p>
<p>This function returns the amplitude of the fourier transform of the surface brightness profile at a given position in k space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as kx,ky (either as a tuple or as two arguments).</p>
<p>Technically, <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a7a924e2d85a44389099bd8e74e591017" title="Returns the value of the object at a chosen 2D position in k space. ">kValue()</a> is available if and only if the given obj has <code>obj.is_analytic_k == True</code>, but this is the case for all GSObjects currently, so that should never be an issue (unlike for <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a51f44f1d019c34634a41a89c06c9f631" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in k space at which you want the fourier amplitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amplitude of the fourier transform at that position. </dd></dl>

</div>
</div>
<a class="anchor" id="a55d5076291c11a8f0ebd1e75942be4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.lens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with both a lensing shear and magnification applied to it. </p>
<p>This <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> method applies a lensing (reduced) shear and magnification. The shear must be specified using the g1, g2 definition of shear (see Shear documentation for more details). This is the same definition as the outputs of the PowerSpectrum and NFWHalo classes, which compute shears according to some lensing power spectrum or lensing by an NFW dark matter halo. The magnification determines the rescaling factor for the object area and flux, preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">g2</td><td>Second component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">mu</td><td>Lensing magnification to apply to the object. This is the factor by which the solid angle subtended by the object is magnified, preserving surface brightness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lensed object. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d40a46404ea7674af47459c975e333b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.magnify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by <code>mu</code> at fixed surface brightness. </p>
<p>This process applies a lensing magnification mu, which scales the linear dimensions of the image by the factor sqrt(mu), i.e., <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * sqrt(mu)</code> while increasing the flux by a factor of mu. Thus, <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> preserves surface brightness.</p>
<p>See <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#aa26483093b11e5a0264ee3e0f3ad5acf" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a68ebb301de472bdd366210422ea32f7d" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> for a version that applies a linear scale factor while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>The lensing magnification to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the magnified object. </dd></dl>

</div>
</div>
<a class="anchor" id="acfa197c3102b55343145dabc3d1a2209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.max_sb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An estimate of the maximum surface brightness of the object. </p>
<p>Some profiles will return the exact peak SB, typically equal to the value of obj.xValue(obj.centroid). However, not all profiles (e.g. Convolution) know how to calculate this value without just drawing the image and checking what the maximum value is. Clearly, this would be inefficient, so in these cases, some kind of estimate is returned, which will generally be conservative on the high side.</p>
<p>This routine is mainly used by the photon shooting process, where an overestimate of the maximum surface brightness is acceptable.</p>
<p>Note, for negative-flux profiles, this will return the absolute value of the most negative surface brightness. Technically, it is an estimate of the maximum deviation from zero, rather than the maximum value. For most profiles, these are the same thing. </p>

</div>
</div>
<a class="anchor" id="ac40af39da0fab05eae24db987ea9504d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.maxk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of k beyond which aliasing can be neglected. </p>

</div>
</div>
<a class="anchor" id="a925aed2e591399c744c4ddceccb304d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.maxK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe5e7e6d59f09e48e53ed566c54fdc49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.maxSB </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addd22388666a94b6f96786c4e8574292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.negative_flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The expectation value of the flux in negative photons when <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac2d8564b67da04c55ecb4f0b882a8f96" title="Shoot photons into a PhotonArray. ">shoot()</a> is called. </p>
<p>Some profiles (such as InterpolatedImages) have components with negative flux, which requires some negative-flux photons to be shot when rendering with photon shooting. This routine returns the total (absolute) flux in negative photons, which for most profiles is just 0, but for the ones that require some negative-flux photons will be non-zero.</p>
<p>It should be generally true that <code>positive_flux - negative_flux</code> returns the same thing as <code>obj.flux</code>. Small difference may accrue from finite numerical accuracy in cases involving lookup tables, etc. </p>

</div>
</div>
<a class="anchor" id="a52713c692124c1419e71690c1f3a8e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.noise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc5ec66e641a5f29337b5f42e97960cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.nyquist_scale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Image pixel spacing that does not alias maxk. </p>

</div>
</div>
<a class="anchor" id="a62f3ac816884d0f2f5a32939d87b40fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.nyquistScale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acbc89dc8d1c65806516c53f31d74b4ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.positive_flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The expectation value of the flux in positive photons when <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#ac2d8564b67da04c55ecb4f0b882a8f96" title="Shoot photons into a PhotonArray. ">shoot()</a> is called. </p>
<p>Some profiles (such as InterpolatedImages) have components with negative flux, which requires some negative-flux photons to be shot when rendering with photon shooting. This routine returns the total flux in positive photons, which for most profiles is just the total flux, but for the ones that require some negative-flux photons will be a bit larger.</p>
<p>It should be generally true that <code>positive_flux - negative_flux</code> returns the same thing as <code>obj.flux</code>. Small difference may accrue from finite numerical accuracy in cases involving lookup tables, etc. </p>

</div>
</div>
<a class="anchor" id="a6154d3b762748b3441dd547d41593cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.rotate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> <code>theta</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Rotation angle (<a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> object, +ve anticlockwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca82815f68409e324fca1caf46d8a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.SBProfile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ee61aad28535bc5486b6f8fdfdca6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.SED </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0817750dfb31833cf47cc399d4699ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.separable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93a9c46634d62f37ff5cb7358ce73a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with an area-preserving shear applied to it. </p>
<p>The arguments may be either a Shear instance or arguments to be used to initialize one.</p>
<p>For more details about the allowed keyword arguments, see the documentation for Shear (for doxygen documentation, see <a class="el" href="classgalsim_1_1shear_1_1_shear.html" title="A class to represent shears in a variety of ways. ">galsim.shear.Shear</a>).</p>
<p>The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a93a9c46634d62f37ff5cb7358ce73a85" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> method precisely preserves the area. To include a lensing distortion with the appropriate change in area, either use <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a93a9c46634d62f37ff5cb7358ce73a85" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> with <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a>, or use <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a55d5076291c11a8f0ebd1e75942be4ec" title="Create a version of the current object with both a lensing shear and magnification applied to it...">lens()</a>, which combines both operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shear</td><td>The Shear to be applied. Or, as described above, you may instead supply parameters do construct a shear directly. eg. <code>obj.shear(g1=g1,g2=g2)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sheared object. </dd></dl>

</div>
</div>
<a class="anchor" id="a41314ad780e3f646f2194bf372465bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object shifted by some amount in real space. </p>
<p>After this call, the caller's type will be a <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. This means that if the caller was a derived type that had extra methods beyond those defined in <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> (e.g. getSigma() for a Gaussian), then these methods are no longer available.</p>
<p>Note: in addition to the dx,dy parameter names, you may also supply dx,dy as a tuple, or as a PositionD or PositionI object.</p>
<p>The shift coordinates here are sky coordinates. GSObjects are always defined in sky coordinates and only later (when they are drawn) is the connection to pixel coordinates established (via a pixel_scale or WCS). So a shift of dx moves the object horizontally in the sky (e.g. west in the local tangent plane of the observation), and dy moves the object vertically (north in the local tangent plane).</p>
<p>The units are typically arcsec, but we don't enforce that anywhere. The units here just need to be consistent with the units used for any size values used by the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. The connection of these units to the eventual image pixels is defined by either the <code>pixel_scale</code> or the <code>wcs</code> parameter of <code>drawImage</code>.</p>
<p>Note: if you want to shift the object by a set number (or fraction) of pixels in the drawn image, you probably want to use the <code>offset</code> parameter of <code>drawImage</code> rather than this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Horizontal shift to apply. </td></tr>
    <tr><td class="paramname">dy</td><td>Vertical shift to apply. &ndash; or &ndash; </td></tr>
    <tr><td class="paramname">offset</td><td>The shift to apply, given as PositionD(dx,dy) or PositionI(dx,dy)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2d8564b67da04c55ecb4f0b882a8f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.shoot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shoot photons into a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_photons</td><td>The number of photons to use for photon shooting. </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aedf48bfd51ca8c10eec21137f78941b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.spectral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa432af2a0aaaf87c46c9da12eb4010f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.stepk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sampling in k space necessary to avoid folding of image in x space. </p>

</div>
</div>
<a class="anchor" id="ad7d349d31f1feb37c4ba678bb411e2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.stepK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1572f542a2150a588f43389e9f30b273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it. </p>
<p>This applies a Jacobian matrix to the coordinate system in which this object is defined. It changes a profile defined in terms of (x,y) to one defined in terms of (u,v) where: </p>
<pre class="fragment">u = dudx x + dudy y
v = dvdx x + dvdy y
</pre><p>That is, an arbitrary affine transform, but without the translation (which is easily effected via the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a41314ad780e3f646f2194bf372465bfa" title="Create a version of the current object shifted by some amount in real space. ">shift()</a> method).</p>
<p>Note that this function is similar to expand in that it preserves surface brightness, not flux. If you want to preserve flux, you should also do </p>
<pre class="fragment">&gt;&gt;&gt; prof *= 1./abs(dudx*dvdy - dudy*dvdx)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dudx</td><td>du/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dudy</td><td>du/dy, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdx</td><td>dv/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdy</td><td>dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transformed object </dd></dl>

</div>
</div>
<a class="anchor" id="ae8fcfe5d0f71eb772969567a4f94d62c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.wave_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc8d45679dfc86f63e46de5524639bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.withFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with a different flux. </p>
<p>This function is equivalent to <code>obj.withScaledFlux(flux / obj.flux)</code>.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location rescaled such that the total flux will be the given value. Note that if <code>flux</code> is an <code>SED</code>, the return value will be a <code>ChromaticObject</code> with specified SED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux</td><td>The new flux for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux </dd></dl>

</div>
</div>
<a class="anchor" id="a39b00698a20025ead0678dc1bd847853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.withScaledFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>. </p>
<p>This function is equivalent to <code>obj.withFlux(flux_ratio * obj.flux)</code>. Indeed, <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#abc8d45679dfc86f63e46de5524639bb3" title="Create a version of the current object with a different flux. ">withFlux()</a> is implemented in terms of this one.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount. If <code>flux_ratio</code> is an SED, then the returned object is a <code>ChromaticObject</code> with an SED multiplied by obj.flux. Note that in this case the <code>.flux</code> attribute of the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> being scaled gets interpreted as being dimensionless, instead of having its normal units of [photons/s/cm^2]. The photons/s/cm^2 units are (optionally) carried by the SED instead, or even left out entirely if the SED is dimensionless itself (see discussion in the ChromaticObject docstring). The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> <code>flux</code> attribute <em>does</em> still contribute to the ChromaticObject normalization, though. For example, the following are equivalent: </p>
<pre class="fragment">&gt;&gt;&gt; chrom_obj = gsobj.withScaledFlux(sed * 3.0)
&gt;&gt;&gt; chrom_obj2 = (gsobj * 3.0).withScaledFlux(sed)
</pre><p>An equivalent, and usually simpler, way to effect this scaling is </p>
<pre class="fragment">&gt;&gt;&gt; obj = obj * flux_ratio
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux_ratio</td><td>The ratio by which to rescale the flux of the object when creating a new one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a51f44f1d019c34634a41a89c06c9f631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.GSObject.xValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in real space. </p>
<p>This function returns the surface brightness of the object at a particular position in real space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as x,y (either as a tuple or as two arguments).</p>
<p>The object surface brightness profiles are typically defined in world coordinates, so the position here should be in world coordinates as well.</p>
<p>Not all <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> classes can use this method. Classes like Convolution that require a Discrete Fourier Transform to determine the real space values will not do so for a single position. Instead a RuntimeError will be raised. The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a51f44f1d019c34634a41a89c06c9f631" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method is available if and only if <code>obj.is_analytic_x == True</code>.</p>
<p>Users who wish to use the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a51f44f1d019c34634a41a89c06c9f631" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for an object that is the convolution of other profiles can do so by drawing the convolved profile into an image, using the image to initialize a new InterpolatedImage, and then using the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html#a51f44f1d019c34634a41a89c06c9f631" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for that new object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position at which you want the surface brightness of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the surface brightness at that position. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="adb96a86d456346183b76f4509d11c34b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.gsobject.GSObject.flux</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="gsobject_8py.html">gsobject.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
