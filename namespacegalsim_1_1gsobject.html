<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GalSim: galsim.gsobject Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1gsobject.html">gsobject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">galsim.gsobject Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html">GSObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all GalSim classes that represent some kind of surface brightness profile.  <a href="classgalsim_1_1gsobject_1_1_g_s_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c15cd01110eefc7928d06b154d50ae0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a4c15cd01110eefc7928d06b154d50ae0">gsparams</a> (self)</td></tr>
<tr class="memdesc:a4c15cd01110eefc7928d06b154d50ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#a4c15cd01110eefc7928d06b154d50ae0">More...</a><br /></td></tr>
<tr class="separator:a4c15cd01110eefc7928d06b154d50ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e788d483fd183f1e56939f7243998f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a62e788d483fd183f1e56939f7243998f">maxk</a> (self)</td></tr>
<tr class="separator:a62e788d483fd183f1e56939f7243998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6e47cab50c665224aa7c6ca5e3e25d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a8e6e47cab50c665224aa7c6ca5e3e25d">stepk</a> (self)</td></tr>
<tr class="separator:a8e6e47cab50c665224aa7c6ca5e3e25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ca2218650d47a86f7913af5480367d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a28ca2218650d47a86f7913af5480367d">nyquist_scale</a> (self)</td></tr>
<tr class="separator:a28ca2218650d47a86f7913af5480367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80e3de821a725e619e18709bc803658"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ac80e3de821a725e619e18709bc803658">has_hard_edges</a> (self)</td></tr>
<tr class="separator:ac80e3de821a725e619e18709bc803658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120af2a83a0905c761ca73e1fa0f0129"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a120af2a83a0905c761ca73e1fa0f0129">is_axisymmetric</a> (self)</td></tr>
<tr class="separator:a120af2a83a0905c761ca73e1fa0f0129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e044f7f8ecbf4f015f1546b8a32fe06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a2e044f7f8ecbf4f015f1546b8a32fe06">is_analytic_x</a> (self)</td></tr>
<tr class="separator:a2e044f7f8ecbf4f015f1546b8a32fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b9aa8e3d2ccb9adfa56fce465c328f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a17b9aa8e3d2ccb9adfa56fce465c328f">is_analytic_k</a> (self)</td></tr>
<tr class="separator:a17b9aa8e3d2ccb9adfa56fce465c328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd405f579179f4d48be7807252a1b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ab0bd405f579179f4d48be7807252a1b2">centroid</a> (self)</td></tr>
<tr class="memdesc:ab0bd405f579179f4d48be7807252a1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a different flux.  <a href="#ab0bd405f579179f4d48be7807252a1b2">More...</a><br /></td></tr>
<tr class="separator:ab0bd405f579179f4d48be7807252a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cf0e1c414f8fff18800a747e329c26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#af7cf0e1c414f8fff18800a747e329c26">positive_flux</a> (self)</td></tr>
<tr class="separator:af7cf0e1c414f8fff18800a747e329c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d700b162e2c74304ca487ab315a5e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aa1d700b162e2c74304ca487ab315a5e4">negative_flux</a> (self)</td></tr>
<tr class="separator:aa1d700b162e2c74304ca487ab315a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32148e7e635ad981809d044f50a8a92a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a32148e7e635ad981809d044f50a8a92a">max_sb</a> (self)</td></tr>
<tr class="separator:a32148e7e635ad981809d044f50a8a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f9f5b1fdf5ddffc75f1974fcd11e85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aa7f9f5b1fdf5ddffc75f1974fcd11e85">noise</a> (self)</td></tr>
<tr class="separator:aa7f9f5b1fdf5ddffc75f1974fcd11e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5d60a49f5202147791b29bbe1d73f2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a3b5d60a49f5202147791b29bbe1d73f2">noise</a> (self, n)</td></tr>
<tr class="separator:a3b5d60a49f5202147791b29bbe1d73f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f220be92202d1e095c2232b5ad750f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a7f220be92202d1e095c2232b5ad750f9">separable</a> (self)</td></tr>
<tr class="separator:a7f220be92202d1e095c2232b5ad750f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94227359893297c1c509ca1760d644a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a94227359893297c1c509ca1760d644a3">interpolated</a> (self)</td></tr>
<tr class="separator:a94227359893297c1c509ca1760d644a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d6df002ad96da953319ea9ae312be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a977d6df002ad96da953319ea9ae312be">deinterpolated</a> (self)</td></tr>
<tr class="separator:a977d6df002ad96da953319ea9ae312be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8460e71958b78a8bf0fff5564fe64803"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a8460e71958b78a8bf0fff5564fe64803">SED</a> (self)</td></tr>
<tr class="memdesc:a8460e71958b78a8bf0fff5564fe64803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>.  <a href="#a8460e71958b78a8bf0fff5564fe64803">More...</a><br /></td></tr>
<tr class="separator:a8460e71958b78a8bf0fff5564fe64803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafff15b78fa86378f8a5102cc21fa7ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aafff15b78fa86378f8a5102cc21fa7ed">spectral</a> (self)</td></tr>
<tr class="separator:aafff15b78fa86378f8a5102cc21fa7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254eb9fcdbdcbb94bfb82dd3d1a1b6a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a254eb9fcdbdcbb94bfb82dd3d1a1b6a9">dimensionless</a> (self)</td></tr>
<tr class="separator:a254eb9fcdbdcbb94bfb82dd3d1a1b6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a1c28bb2875092883922735da08f08"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ab1a1c28bb2875092883922735da08f08">wave_list</a> (self)</td></tr>
<tr class="separator:ab1a1c28bb2875092883922735da08f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb518d71fbdf5233157bff8bb149b6f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a3bb518d71fbdf5233157bff8bb149b6f">evaluateAtWavelength</a> (self, wave)</td></tr>
<tr class="separator:a3bb518d71fbdf5233157bff8bb149b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641be964df64c14227818db9f7f536d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a641be964df64c14227818db9f7f536d2">__add__</a> (self, other)</td></tr>
<tr class="separator:a641be964df64c14227818db9f7f536d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4f3ab95e3867d0efa347d7bd5655b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#abb4f3ab95e3867d0efa347d7bd5655b0">__sub__</a> (self, other)</td></tr>
<tr class="memdesc:abb4f3ab95e3867d0efa347d7bd5655b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness.  <a href="#abb4f3ab95e3867d0efa347d7bd5655b0">More...</a><br /></td></tr>
<tr class="separator:abb4f3ab95e3867d0efa347d7bd5655b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ad77d520f086018609d3e193b74c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a048ad77d520f086018609d3e193b74c0">__mul__</a> (self, other)</td></tr>
<tr class="memdesc:a048ad77d520f086018609d3e193b74c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux.  <a href="#a048ad77d520f086018609d3e193b74c0">More...</a><br /></td></tr>
<tr class="separator:a048ad77d520f086018609d3e193b74c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd2f63c07ee00fedf209bb5d43df43"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ad9dd2f63c07ee00fedf209bb5d43df43">__rmul__</a> (self, other)</td></tr>
<tr class="separator:ad9dd2f63c07ee00fedf209bb5d43df43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95519e611ad947c36614eac64cdf0056"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a95519e611ad947c36614eac64cdf0056">__div__</a> (self, other)</td></tr>
<tr class="separator:a95519e611ad947c36614eac64cdf0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1146a21f4391786ddcc977df32222f60"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a1146a21f4391786ddcc977df32222f60">__neg__</a> (self)</td></tr>
<tr class="separator:a1146a21f4391786ddcc977df32222f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411b1d7ba8b804ea285bbe5b7a3a0981"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a411b1d7ba8b804ea285bbe5b7a3a0981">calculateHLR</a> (self, size=None, scale=None, <a class="el" href="namespacegalsim_1_1gsobject.html#ab0bd405f579179f4d48be7807252a1b2">centroid</a>=None, flux_frac=0.5)</td></tr>
<tr class="memdesc:a411b1d7ba8b804ea285bbe5b7a3a0981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this profile into an Image by direct evaluation at the location of each pixel.  <a href="#a411b1d7ba8b804ea285bbe5b7a3a0981">More...</a><br /></td></tr>
<tr class="separator:a411b1d7ba8b804ea285bbe5b7a3a0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7606699057744fe5c796695f977ea2fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a7606699057744fe5c796695f977ea2fe">calculateMomentRadius</a> (self, size=None, scale=None, <a class="el" href="namespacegalsim_1_1gsobject.html#ab0bd405f579179f4d48be7807252a1b2">centroid</a>=None, rtype='det')</td></tr>
<tr class="separator:a7606699057744fe5c796695f977ea2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27de52b8652660c5605afca893b9cdd9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a27de52b8652660c5605afca893b9cdd9">calculateFWHM</a> (self, size=None, scale=None, <a class="el" href="namespacegalsim_1_1gsobject.html#ab0bd405f579179f4d48be7807252a1b2">centroid</a>=None)</td></tr>
<tr class="separator:a27de52b8652660c5605afca893b9cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a5aae085d62f2fb25f099205474d57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a59a5aae085d62f2fb25f099205474d57">xValue</a> (self, args, kwargs)</td></tr>
<tr class="separator:a59a5aae085d62f2fb25f099205474d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2461ca769d1d0dc874ac0e710e2326d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a2461ca769d1d0dc874ac0e710e2326d8">kValue</a> (self, args, kwargs)</td></tr>
<tr class="separator:a2461ca769d1d0dc874ac0e710e2326d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5300dc23b60baa5e7020491e9b40567"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aa5300dc23b60baa5e7020491e9b40567">withGSParams</a> (self, <a class="el" href="namespacegalsim_1_1gsobject.html#a4c15cd01110eefc7928d06b154d50ae0">gsparams</a>)</td></tr>
<tr class="separator:aa5300dc23b60baa5e7020491e9b40567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794d75d32920b4903e8b238a6d65e06b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a794d75d32920b4903e8b238a6d65e06b">withFlux</a> (self, <a class="el" href="namespacegalsim_1_1gsobject.html#a55cc27dc0194c107fa345f68d4612550">flux</a>)</td></tr>
<tr class="separator:a794d75d32920b4903e8b238a6d65e06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88f4babc5c4e58c53877c86d227712a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aa88f4babc5c4e58c53877c86d227712a">withScaledFlux</a> (self, flux_ratio)</td></tr>
<tr class="separator:aa88f4babc5c4e58c53877c86d227712a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ca0de3443c2505d5d39bbb913be78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a959ca0de3443c2505d5d39bbb913be78">expand</a> (self, scale)</td></tr>
<tr class="separator:a959ca0de3443c2505d5d39bbb913be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b15b6b1b19760dbcec55df2ebb8e9e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a74b15b6b1b19760dbcec55df2ebb8e9e">dilate</a> (self, scale)</td></tr>
<tr class="separator:a74b15b6b1b19760dbcec55df2ebb8e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c7425148437d0ca97bb1891e20cfd7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a64c7425148437d0ca97bb1891e20cfd7">magnify</a> (self, mu)</td></tr>
<tr class="separator:a64c7425148437d0ca97bb1891e20cfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cae2c77532c9be663fc55f59fb55c06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a2cae2c77532c9be663fc55f59fb55c06">shear</a> (self, args, kwargs)</td></tr>
<tr class="separator:a2cae2c77532c9be663fc55f59fb55c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2251c40af156536ec9bb424d6445c145"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a2251c40af156536ec9bb424d6445c145">lens</a> (self, g1, g2, mu)</td></tr>
<tr class="separator:a2251c40af156536ec9bb424d6445c145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d24b55ce76143422839ae65763d95dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a9d24b55ce76143422839ae65763d95dd">rotate</a> (self, theta)</td></tr>
<tr class="separator:a9d24b55ce76143422839ae65763d95dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83ddcb69020c3e8f9567dc23f7ad697"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ae83ddcb69020c3e8f9567dc23f7ad697">transform</a> (self, dudx, dudy, dvdx, dvdy)</td></tr>
<tr class="separator:ae83ddcb69020c3e8f9567dc23f7ad697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257acf514b2875ac6c0804503338dfa4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a257acf514b2875ac6c0804503338dfa4">shift</a> (self, args, kwargs)</td></tr>
<tr class="separator:a257acf514b2875ac6c0804503338dfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6973ff2ec617b3bce96aef8989afc41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ae6973ff2ec617b3bce96aef8989afc41">drawImage</a> (self, image=None, nx=None, ny=None, bounds=None, scale=None, wcs=None, dtype=None, method='auto', area=1., exptime=1., gain=1., add_to_image=False, use_true_center=True, offset=None, n_photons=0., rng=None, max_extra_noise=0., poisson_flux=None, sensor=None, surface_ops=(), n_subsample=3, maxN=None, save_photons=False, setup_only=False)</td></tr>
<tr class="memdesc:ae6973ff2ec617b3bce96aef8989afc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this profile into an Image by shooting photons.  <a href="#ae6973ff2ec617b3bce96aef8989afc41">More...</a><br /></td></tr>
<tr class="separator:ae6973ff2ec617b3bce96aef8989afc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397edd083aaa67c2d977684bdf39e212"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a397edd083aaa67c2d977684bdf39e212">drawReal</a> (self, image, add_to_image=False)</td></tr>
<tr class="separator:a397edd083aaa67c2d977684bdf39e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572a08c6fe143b3cf4b68682265ef578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a572a08c6fe143b3cf4b68682265ef578">getGoodImageSize</a> (self, pixel_scale)</td></tr>
<tr class="separator:a572a08c6fe143b3cf4b68682265ef578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cabc4c3639d7197d3530dbc12f8b52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a22cabc4c3639d7197d3530dbc12f8b52">drawFFT_makeKImage</a> (self, image)</td></tr>
<tr class="separator:a22cabc4c3639d7197d3530dbc12f8b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403fe8a0bd82746ec8eafbba125ae33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a2403fe8a0bd82746ec8eafbba125ae33">drawFFT_finish</a> (self, image, kimage, wrap_size, add_to_image)</td></tr>
<tr class="separator:a2403fe8a0bd82746ec8eafbba125ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2cf9cce688bc09dfefbced6dff45b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a0f2cf9cce688bc09dfefbced6dff45b3">drawFFT</a> (self, image, add_to_image=False)</td></tr>
<tr class="separator:a0f2cf9cce688bc09dfefbced6dff45b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9a5d6668a021b5497fb3ea190629da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aec9a5d6668a021b5497fb3ea190629da">drawPhot</a> (self, image, gain=1., add_to_image=False, n_photons=0, rng=None, max_extra_noise=0., poisson_flux=None, sensor=None, surface_ops=(), maxN=None, orig_center=<a class="el" href="classgalsim_1_1position_1_1_position_i.html">PositionI</a>(0, 0), local_wcs=None)</td></tr>
<tr class="separator:aec9a5d6668a021b5497fb3ea190629da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb21bb4921aa8cca354157be9ed3bd32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#acb21bb4921aa8cca354157be9ed3bd32">shoot</a> (self, n_photons, rng=None)</td></tr>
<tr class="separator:acb21bb4921aa8cca354157be9ed3bd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2bb7bba98b07bd8b6db5421f2f7f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#aaef2bb7bba98b07bd8b6db5421f2f7f3">drawKImage</a> (self, image=None, nx=None, ny=None, bounds=None, scale=None, add_to_image=False, recenter=True, setup_only=False)</td></tr>
<tr class="separator:aaef2bb7bba98b07bd8b6db5421f2f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72977070cb365f9e9ae5b550acb046d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#ab72977070cb365f9e9ae5b550acb046d">__ne__</a> (self, other)</td></tr>
<tr class="separator:ab72977070cb365f9e9ae5b550acb046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a55cc27dc0194c107fa345f68d4612550"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1gsobject.html#a55cc27dc0194c107fa345f68d4612550">flux</a></td></tr>
<tr class="separator:a55cc27dc0194c107fa345f68d4612550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a641be964df64c14227818db9f7f536d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641be964df64c14227818db9f7f536d2">&#9670;&nbsp;</a></span>__add__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95519e611ad947c36614eac64cdf0056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95519e611ad947c36614eac64cdf0056">&#9670;&nbsp;</a></span>__div__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__div__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a048ad77d520f086018609d3e193b74c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048ad77d520f086018609d3e193b74c0">&#9670;&nbsp;</a></span>__mul__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilate the linear size of the profile by the given <code>scale</code> factor, while preserving flux. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>See <a class="el" href="namespacegalsim_1_1gsobject.html#a959ca0de3443c2505d5d39bbb913be78">expand()</a> and <a class="el" href="namespacegalsim_1_1gsobject.html#a64c7425148437d0ca97bb1891e20cfd7">magnify()</a> for versions that preserve surface brightness, and thus changes the flux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The linear rescaling factor to apply. Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by <code>mu</code> at fixed surface brightness.</td></tr>
  </table>
  </dd>
</dl>
<p>This process applies a lensing magnification mu, which scales the linear dimensions of the image by the factor sqrt(mu), i.e., <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * sqrt(mu)</code> while increasing the flux by a factor of mu. Thus, <a class="el" href="namespacegalsim_1_1gsobject.html#a64c7425148437d0ca97bb1891e20cfd7">magnify()</a> preserves surface brightness.</p>
<p>See <a class="el" href="namespacegalsim_1_1gsobject.html#a74b15b6b1b19760dbcec55df2ebb8e9e">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="namespacegalsim_1_1gsobject.html#a959ca0de3443c2505d5d39bbb913be78">expand()</a> for a version that applies a linear scale factor while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>The lensing magnification to apply. <pre class="fragment">    @returns the magnified object.


    @returns the dilated object.
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Create a version of the current object with an area-preserving shear applied to it. </p><pre class="fragment">    The arguments may be either a Shear instance or arguments to be used to initialize one.

    For more details about the allowed keyword arguments, see the documentation for Shear
</pre><p> Equivalent to self.shear(shear), but without the overhead of sanity checks or other ways to input the shear value.</p>
<p>This is only valid for GSObjects. For ChromaticObjects, you must use the regular shear. Also, it won't propagate any noise attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shear</td><td>The Shear to be applied. Must be a galsim.Shear instance. <pre class="fragment">    @returns the sheared object.

    (for doxygen documentation, see galsim.shear.Shear).

    The shear() method precisely preserves the area.  To include a lensing distortion with
    the appropriate change in area, either use shear() with magnify(), or use lens(), which
    combines both operations.
</pre></td></tr>
    <tr><td class="paramname">shear</td><td>The Shear to be applied. Or, as described above, you may instead supply Create a version of the current object with both a lensing shear and magnification applied to it.</td></tr>
  </table>
  </dd>
</dl>
<p>This <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> method applies a lensing (reduced) shear and magnification. The shear must be specified using the g1, g2 definition of shear (see Shear documentation for more details). This is the same definition as the outputs of the PowerSpectrum and NFWHalo classes, which compute shears according to some lensing power spectrum or lensing by an NFW dark matter halo. The magnification determines the rescaling factor for the object area and flux, preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">g2</td><td>Second component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">mu</td><td>Lensing magnification to apply to the object. This is the factor by which the solid angle subtended by the object is magnified, preserving surface brightness.</td></tr>
  </table>
  </dd>
</dl>
<p>Rotate this object by an Angle <code>theta</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Rotation angle (Angle object, +ve anticlockwise). <pre class="fragment">    @returns the rotated object.

    @returns the lensed object.

                    parameters do construct a shear directly.  eg. `obj.shear(g1=g1,g2=g2)`.

    @returns the sheared object.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab72977070cb365f9e9ae5b550acb046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72977070cb365f9e9ae5b550acb046d">&#9670;&nbsp;</a></span>__ne__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1146a21f4391786ddcc977df32222f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1146a21f4391786ddcc977df32222f60">&#9670;&nbsp;</a></span>__neg__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__neg__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9dd2f63c07ee00fedf209bb5d43df43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dd2f63c07ee00fedf209bb5d43df43">&#9670;&nbsp;</a></span>__rmul__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb4f3ab95e3867d0efa347d7bd5655b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4f3ab95e3867d0efa347d7bd5655b0">&#9670;&nbsp;</a></span>__sub__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the linear size of the profile by the given <code>scale</code> factor, while preserving surface brightness. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>This doesn't correspond to either of the normal operations one would typically want to do to a galaxy. The functions <a class="el" href="namespacegalsim_1_1gsobject.html#a74b15b6b1b19760dbcec55df2ebb8e9e">dilate()</a> and <a class="el" href="namespacegalsim_1_1gsobject.html#a64c7425148437d0ca97bb1891e20cfd7">magnify()</a> are the more typical usage. But this function is conceptually simple. It rescales the linear dimension of the profile, while preserving surface brightness. As a result, the flux will necessarily change as well.</p>
<p>See <a class="el" href="namespacegalsim_1_1gsobject.html#a74b15b6b1b19760dbcec55df2ebb8e9e">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="namespacegalsim_1_1gsobject.html#a64c7425148437d0ca97bb1891e20cfd7">magnify()</a> for a version that applies a scale factor to the area while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The factor by which to scale the linear dimension of the object. <pre class="fragment">    @returns the expanded object.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27de52b8652660c5605afca893b9cdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27de52b8652660c5605afca893b9cdd9">&#9670;&nbsp;</a></span>calculateFWHM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.calculateFWHM </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a411b1d7ba8b804ea285bbe5b7a3a0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411b1d7ba8b804ea285bbe5b7a3a0981">&#9670;&nbsp;</a></span>calculateHLR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.calculateHLR </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_frac</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw this profile into an Image by direct evaluation at the location of each pixel. </p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p><pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawReal</code> represents the profile sampled at the center of each pixel and then multiplied by the pixel area. That is, the profile is NOT integrated over the area of the pixel. This is equivalent to method='no_pixel' in drawImage. If you want to render a profile integrated over the pixel, you can convolve Equivalent to the regular drawReal(image, add_to_image=False), but without the usual sanity checks, and the image's dtype must be either float32 or float64, and it must have a c_contiguous array (image.iscontiguous must be True).</p>
<p>with a Pixel first and draw that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds.</dd></dl>
<pre class="fragment">    If drawImage() will be creating the image from scratch for you, then there are several ways
    to control the size of the new image.  If the `nx` and `ny` keywords are present, then an
    image with these numbers of pixels on a side will be created.  Similarly, if the `bounds`
    keyword is present, then an image with the specified bounds will be created.  Note that it
    is an error to provide an existing Image when also specifying `nx`, `ny`, or `bounds`. In
    the absence of `nx`, `ny`, and `bounds`, drawImage will decide a good size to use based on
    the size of the object being drawn.  Basically, it will try to use an area large enough to
    include at least 99.5% of the flux.  (Note: the value 0.995 is really `1 -
    folding_threshold`.  You can change the value of `folding_threshold` for any object via
</pre><p> Return a good size to use for drawing this profile. </p><pre class="fragment">    The size will be large enough to cover most of the flux of the object.  Specifically,
    at least (1-gsparams.folding_threshold) (i.e. 99.5% by default) of the flux should fall
    in the image.

    Also, the returned size is always an even number, which is usually desired in practice.
    Of course, if you prefer an odd-sized image, you can add 1 to the result.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixel_scale</td><td>The desired pixel scale of the image to be built. <pre class="fragment">    @returns N, a good (linear) size of an image on which to draw this object.

    GSParams.  See `help(GSParams)` for more details.)  You can set the pixel scale of the

    This is a helper routine for drawFFT that just makes the (blank) k-space image
    onto which the profile will be drawn.  This can be useful if you want to break
    up the calculation into parts for extra efficiency.  E.g. save the k-space image of
    the PSF so drawing many models of the galaxy with the given PSF profile can avoid
    drawing the PSF each time.
</pre></td></tr>
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. <pre class="fragment">    @returns (kimage, wrap_size), where wrap_size is either the size of kimage or smaller if
                                  the result should be wrapped before doing the inverse fft.

    constructed image with the `scale` parameter, or set a WCS function with `wcs`.  If you do
    not provide either `scale` or `wcs`, then drawImage() will default to using the Nyquist
    scale for the current object.  You can also set the data type used in the new Image with the
    `dtype` parameter that has the same options as for the Image constructor.

    The drawing "method"
    --------------------

    There are several different possible methods drawImage() can use for rendering the image.
    This is set by the `method` parameter.  The options are:

        'auto'      This is the default, which will normally be equivalent to 'fft'.  However,
                    if the object being rendered is simple (no convolution) and has hard edges
                    (e.g. a Box or a truncated Moffat or Sersic), then it will switch to
                    'real_space', since that is often both faster and more accurate in these
                    cases (due to ringing in Fourier space).


    This is a helper routine for drawFFT that finishes the calculation, based on the
    drawn k-space image.

    It applies the Fourier transform to `kimage` and adds the result to `image`.
</pre></td></tr>
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. </td></tr>
    <tr><td class="paramname">kimage</td><td>The k-space Image where the object was drawn. </td></tr>
    <tr><td class="paramname">wrap_size</td><td>The size of the region to wrap kimage, which must be either the same size as kimage or smaller. </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds. <pre class="fragment">'fft'       The integration of the light within each pixel is mathematically equivalent
            to convolving by the pixel profile (a Pixel object) and sampling the result
            at the centers of the pixels.  This method will do that convolution using
            a discrete Fourier transform.  Furthermore, if the object (or any component
            of it) has been transformed via shear(), dilate(), etc., then these
            transformations are done in Fourier space as well.

'real_space'  This uses direct integrals (using the Gauss-Kronrod-Patterson algorithm)
            in real space for the integration over the pixel response.  It is usually
            slower than the 'fft' method, but if the profile has hard edges that cause
            ringing in Fourier space, it can be faster and/or more accurate.  If you
            use 'real_space' with something that is already a Convolution, then this
            will revert to 'fft', since the double convolution that is required to also
            handle the pixel response is far too slow to be practical using real-space
            integrals.

'phot'      This uses a technique called photon shooting to render the image.
            Essentially, the object profile is taken as a probability distribution
            from which a finite number of photons are "shot" onto the image.  Each
            photon's flux gets added to whichever pixel the photon hits.  This process
            automatically accounts for the integration of the light over the pixel
            area, since all photons that hit any part of the pixel are counted.
</pre></dd></dl>
<p>Draw this profile into an Image by computing the k-space image and performing an FFT.</p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p><pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawFFT</code> represents the profile sampled at the center of each pixel and then multiplied by the pixel area. That is, the profile is NOT integrated over the area of the pixel. This is equivalent to method='no_pixel' in drawImage. If you want to render a profile integrated over the pixel, you can convolve with a Pixel first and draw that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flux drawn inside the image bounds.</dd></dl>
<pre class="fragment">                    Convolutions and transformations are simple geometric processes in this
                    framework.  However, there are two caveats with this method: (1) the
                    resulting image will have Poisson noise from the finite number of photons,
                    and (2) it is not available for all object types (notably anything that
                    includes a Deconvolution).

        'no_pixel'  Instead of integrating over the pixels, this method will sample the profile
                    at the centers of the pixels and multiply by the pixel area.  If there is
                    a convolution involved, the choice of whether this will use an FFT or
                    real-space calculation is governed by the `real_space` parameter of the
                    Convolution class.  This method is the appropriate choice if you are using
                    a PSF that already includes a convolution by the pixel response.  For
                    example, if you are using a PSF from an observed image of a star, then it
                    has already been convolved by the pixel, so you would not want to do so
                    again.  Note: The multiplication by the pixel area gets the flux
                    normalization right for the above use case.  cf. `method = 'sb'`.

        'sb'        This is a lot like 'no_pixel', except that the image values will simply be
                    the sampled object profile's surface brightness, not multiplied by the
                    pixel area.  This does not correspond to any real observing scenario, but
                    it could be useful if you want to view the surface brightness profile of an
                    object directly, without including the pixel integration.

    The 'phot' method has a few extra parameters that adjust how it functions.  The total
    number of photons to shoot is normally calculated from the object's flux.  This flux is
    taken to be given in photons/cm^2/s, so for most simple profiles, this times area * exptime
    will equal the number of photons shot.  (See the discussion in Rowe et al, 2015, for why
    this might be modified for InterpolatedImage and related profiles.)  However, you can
    manually set a different number of photons with `n_photons`.  You can also set
    `max_extra_noise` to tell drawImage() to use fewer photons than normal (and so is faster)
    such that no more than that much extra noise is added to any pixel.  This is particularly
    useful if you will be subsequently adding sky noise, and you can thus tolerate more noise
    than the normal number of photons would give you, since using fewer photons is of course
    faster.  Finally, the default behavior is to have the total flux vary as a Poisson random
    variate, which is normally appropriate with photon shooting.  But you can turn this off with
    `poisson_flux=False`.  It also defaults to False if you set an explicit value for
    `n_photons`.

    Given the periodicity implicit in the use of FFTs, there can occasionally be artifacts due
    to wrapping at the edges, particularly for objects that are quite extended (e.g., due to
    the nature of the radial profile). See `help(galsim.GSParams)` for parameters that you can
    use to reduce the level of these artifacts, in particular `folding_threshold` may be
    helpful if you see such artifacts in your images.

    Setting the offset
    ------------------

    The object will by default be drawn with its nominal center at the center location of the
    image.  There is thus a qualitative difference in the appearance of the rendered profile
    when drawn on even- and odd-sized images.  For a profile with a maximum at (0,0), this
    maximum will fall in the central pixel of an odd-sized image, but in the corner of the four
    central pixels of an even-sized image.  There are two parameters that can affect this
    behavior.  If you want the nominal center to always fall at the center of a pixel, you can
    use `use_true_center=False`.  This will put the object's center at the position
    `image.center` which is an integer pixel value, and is not the true center of an
    even-sized image.  You can also arbitrarily offset the profile from the image center with
    the `offset` parameter to handle any sub-pixel dithering you want.

    Setting the overall normalization
    ---------------------------------

    Normally, the flux of the object should be equal to the sum of all the pixel values in the
    image, less some small amount of flux that may fall off the edge of the image (assuming you
    don't use `method='sb'`).  However, you may optionally set a `gain` value, which converts
    between photons and ADU (so-called analog-to-digital units), the units of the pixel values
    in real images.  Normally, the gain of a CCD is in electrons/ADU, but in GalSim, we fold the
    quantum efficiency into the gain as well, so the units are photons/ADU.

    Another caveat is that, technically, flux is really in units of photons/cm^2/s, not photons.
    So if you want, you can keep track of this properly and provide an `area` and `exposure`
    time here. This detail is more important with chromatic objects where the SED is typically
    given in erg/cm^2/s/nm, so the exposure time and area are important details. With achromatic
    objects however, it is often more convenient to ignore these details and just consider the
    flux to be the total number of photons for this exposure, in which case, you would leave the
    area and exptime parameters at their default value of 1.

    On return, the image will have an attribute `added_flux`, which will be set to the total
    flux added to the image.  This may be useful as a sanity check that you have provided a
    large enough image to catch most of the flux.  For example:

        &gt;&gt;&gt; obj.drawImage(image)
        &gt;&gt;&gt; assert image.added_flux &gt; 0.99 * obj.flux

    The appropriate threshold will depend on your particular application, including what kind
    of profile the object has, how big your image is relative to the size of your object,
    whether you are keeping `poisson_flux=True`, etc.

    The following code snippet illustrates how `gain`, `exptime`, `area`, and `method` can all
    influence the relationship between the `flux` attribute of a `GSObject` and both the pixel
    values and `.added_flux` attribute of an `Image` drawn with `drawImage()`:

        &gt;&gt;&gt; obj = galsim.Gaussian(fwhm=1)
        &gt;&gt;&gt; obj.flux
        1.0
        &gt;&gt;&gt; im = obj.drawImage()
        &gt;&gt;&gt; im.added_flux
        0.9999630988657515
        &gt;&gt;&gt; im.array.sum()
        0.99996305
        &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10)
        &gt;&gt;&gt; im.added_flux
        0.9999630988657525
        &gt;&gt;&gt; im.array.sum()
        99.996315
        &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, method='sb', scale=0.5, nx=10, ny=10)
        &gt;&gt;&gt; im.added_flux
        0.9999973790505298
        &gt;&gt;&gt; im.array.sum()
        399.9989
        &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, gain=2)
        &gt;&gt;&gt; im.added_flux
        0.9999630988657525
        &gt;&gt;&gt; im.array.sum()
        49.998158

    Using a non-trivial sensor
    --------------------------

    Normally the sensor is modeled as an array of pixels where any photon that hits a given
    pixel is accumulated into that pixel.  The final pixel value then just reflects the total
    number of pixels that hit each sensor.  However, real sensors do not (quite) work this way.

    In real CCDs, the photons travel some distance into the silicon before converting to
    electrons.  Then the electrons diffuse laterally some amount as they are pulled by the
    electric field toward the substrate.  Finally, previous electrons that have already been
    deposited will repel subsequent electrons, both slowing down their descent, leading to
    more diffusion, and pushing them laterally toward neighboring pixels, which is called
    the brighter-fatter effect.

    Users interested in modeling this kind of effect can supply a `sensor` object to use
    for the accumulation step.  See `SiliconSensor` in sensor.py for a class that models
    silicon-based CCD sensors.

    Some related effects may need to be done to the photons at the surface layer before being
    passed into the sensor object.  For instance, the photons may need to be given appropriate
    incidence angles according to the optics of the telescope (since this matters for where the
    photons are converted to electrons).  You may also need to give the photons wavelengths
</pre><p> Calculate how many photons to shoot and what flux_ratio (called g) each one should have in order to produce an image with the right S/N and total flux.</p>
<p>This routine is normally called by drawPhot.</p>
<dl class="section return"><dt>Returns</dt><dd>n_photons, g</dd></dl>
<p>according to the SED of the object. Such steps are specified in a <code>surface_ops</code> parameter, which should be a list of any such operations you wish to perform on the photon array before passing them to the sensor. See <code>FRatioAngles</code> and <code>WavelengthSampler</code> in <a class="el" href="photon__array_8py.html" title="Implements the PhotonArray class describing a collection of photons incident on a detector...">photon_array.py</a> for two examples of such surface operators.</p>
<p>Since the sensor deals with photons, it is most natural to use this feature in conjunction with photon shooting (&lsquo;method='phot&rsquo;`). However, it is allowed with FFT methods too. But there is a caveat one should be aware of in this case. The FFT drawing is used to produce an intermediate image, which is then converted to a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> using the factory function <code>PhotonArray.makeFromImage</code>. This assigns photon positions randomly within each pixel where they were drawn, which isn't always a particularly good approximation.</p>
<p>To improve this behavior, the intermediate image is drawn with smaller pixels than the target image, so the photons are given positions closer to their true locations. The amount of subsampling is controlled by the <code>n_subsample</code> parameter, which defaults to 3. Larger values will be more accurate at the expense of larger FFTs (i.e. slower and using more memory).</p>
<h2>Initialization parameters </h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the image on which to draw the profile. If <code>image</code> is None, then an automatically-sized Image will be created. If <code>image</code> is given, but its bounds are undefined (e.g. if it was constructed with <code>image = galsim.Image()</code>), then it will be resized appropriately based on the profile's size [default: None]. </td></tr>
    <tr><td class="paramname">nx</td><td>If provided and <code>image</code> is None, use to set the x-direction size of the image. Must be accompanied by <code>ny</code>. </td></tr>
    <tr><td class="paramname">ny</td><td>If provided and <code>image</code> is None, use to set the y-direction size of the image. Must be accompanied by <code>nx</code>. </td></tr>
    <tr><td class="paramname">bounds</td><td>If provided and <code>image</code> is None, use to set the bounds of the image. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the image. If <code>scale</code> is None and <code>image</code> is given, then take the provided image's pixel scale. If <code>scale</code> is None and <code>image</code> is None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>image</code>), then use the Nyquist scale. If <code>scale &gt; 0</code> and <code>image</code> is given, then override <code>image.scale</code> with the value given as a keyword. [default: None] </td></tr>
    <tr><td class="paramname">wcs</td><td>If provided, use this as the wcs for the image (possibly overriding any existing <code>image.wcs</code>). At most one of <code>scale</code> or <code>wcs</code> may be provided. [default: None] </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type to use for an automatically constructed image. Only valid if <code>image</code> is None. [default: None, which means to use numpy.float32] </td></tr>
    <tr><td class="paramname">method</td><td>Which method to use for rendering the image. See discussion above for the various options and what they do. [default: 'auto'] </td></tr>
    <tr><td class="paramname">area</td><td>Collecting area of telescope in cm^2. [default: 1.] </td></tr>
    <tr><td class="paramname">exptime</td><td>Exposure time in s. [default: 1.] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. Note: This requires that <code>image</code> be provided and that it have defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">use_true_center</td><td>Normally, the profile is drawn to be centered at the true center of the image (using the property image.true_center). If you would rather use the integer center (given by image.center), set this to <code>False</code>. [default: True] </td></tr>
    <tr><td class="paramname">offset</td><td>The location in pixel coordinates at which to center the profile being drawn relative to the center of the image (either the true center if <code>use_true_center=True</code> or nominal center if <code>use_true_center=False</code>). [default: None] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use for photon shooting. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel when photon shooting. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, then you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. [default: 0.] </td></tr>
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples when photon shooting. [default: True, unless <code>n_photons</code> is given, in which case the default is False] </td></tr>
    <tr><td class="paramname">sensor</td><td>An optional Sensor instance, which will be used to accumulate the photons onto the image. [default: None] </td></tr>
    <tr><td class="paramname">surface_ops</td><td>A list of operators that can modify the photon array that will be applied in order before accumulating the photons on the sensor. [default: ()] </td></tr>
    <tr><td class="paramname">n_subsample</td><td>The number of sub-pixels per final pixel to use for fft drawing when using a sensor. The sensor step needs to know the sub-pixel positions of the photons, which is lost in the fft method. So using smaller pixels for the fft step keeps some of that information, making the assumption of uniform flux per pixel less bad of an approximation. [default: 3] </td></tr>
    <tr><td class="paramname">maxN</td><td>Sets the maximum number of photons that will be added to the image at a time. (Memory requirements are proportional to this number.) [default: None, which means no limit] </td></tr>
    <tr><td class="paramname">save_photons</td><td>If True, save the <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> as <code>image.photons</code>. Only valid if method is 'phot' or sensor is not None. [default: False] </td></tr>
    <tr><td class="paramname">setup_only</td><td>Don't actually draw anything on the image. Just make sure the image is set up correctly. This is used internally by GalSim, but there may be cases where the user will want the same functionality. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the drawn Image.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dy</td><td>Vertical shift to apply. &ndash; or &ndash; </td></tr>
    <tr><td class="paramname">offset</td><td>The shift to apply, given as PositionD(dx,dy) or PositionI(dx,dy) <pre class="fragment">    @returns the shifted object.

    @returns the transformed object
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>The offset is to make all the rsq values different to help the precision a bit. </p>

</div>
</div>
<a id="a7606699057744fe5c796695f977ea2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7606699057744fe5c796695f977ea2fe">&#9670;&nbsp;</a></span>calculateMomentRadius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.calculateMomentRadius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'det'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0bd405f579179f4d48be7807252a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd405f579179f4d48be7807252a1b2">&#9670;&nbsp;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with a different flux. </p>
<p>This function is equivalent to <code>obj.withScaledFlux(flux / obj.flux)</code>.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location rescaled such that the total flux will be the given value. Note that if <code>flux</code> is an <code>SED</code>, the return value will be a <code>ChromaticObject</code> with specified SED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux</td><td>The new flux for the object. <pre class="fragment">    @returns the object with the new flux</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977d6df002ad96da953319ea9ae312be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977d6df002ad96da953319ea9ae312be">&#9670;&nbsp;</a></span>deinterpolated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.deinterpolated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74b15b6b1b19760dbcec55df2ebb8e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b15b6b1b19760dbcec55df2ebb8e9e">&#9670;&nbsp;</a></span>dilate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.dilate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a254eb9fcdbdcbb94bfb82dd3d1a1b6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254eb9fcdbdcbb94bfb82dd3d1a1b6a9">&#9670;&nbsp;</a></span>dimensionless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.dimensionless </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f2cf9cce688bc09dfefbced6dff45b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2cf9cce688bc09dfefbced6dff45b3">&#9670;&nbsp;</a></span>drawFFT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2403fe8a0bd82746ec8eafbba125ae33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2403fe8a0bd82746ec8eafbba125ae33">&#9670;&nbsp;</a></span>drawFFT_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawFFT_finish </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kimage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22cabc4c3639d7197d3530dbc12f8b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cabc4c3639d7197d3530dbc12f8b52">&#9670;&nbsp;</a></span>drawFFT_makeKImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawFFT_makeKImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6973ff2ec617b3bce96aef8989afc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6973ff2ec617b3bce96aef8989afc41">&#9670;&nbsp;</a></span>drawImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exptime</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_true_center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sensor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>surface_ops</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_subsample</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxN</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>save_photons</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw this profile into an Image by shooting photons. </p>
<p>This is usually called from the <code>drawImage</code> function, rather than called directly by the user. In particular, the input image must be already set up with defined bounds. The profile will be drawn centered on whatever pixel corresponds to (0,0) with the given bounds, not the image center (unlike drawImage). The image also must have a PixelScale wcs. The profile being drawn should have already been converted to image coordinates via </p><pre class="fragment">&gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)
</pre><p>Note that the image produced by <code>drawPhot</code> represents the profile integrated over the area of each pixel. This is equivalent to convolving the profile by a square <code>Pixel</code> profile and sampling the value at the center of each pixel, although this happens automatically by the shooting algorithm, so you do not need to manually convolve by a Pixel as you would for <code>drawReal</code> or <code>drawFFT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Image onto which to place the flux. [required] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1.] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. [default: False] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use for photon shooting. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel when photon shooting. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, then you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. Shoot photons into a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a>.</td></tr>
    <tr><td class="paramname">n_photons</td><td>The number of photons to use for photon shooting. </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting, which may be any kind of <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> object. If <code>rng</code> is None, one will be automatically created, using the time as a seed. [default: None] Shoot photons into the given <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a></td></tr>
    <tr><td class="paramname">photons</td><td>A <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> instance into which the photons should be placed. </td></tr>
    <tr><td class="paramname">ud</td><td>A <a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.). ">UniformDeviate</a> instance to use for the photon shooting,</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">    @returns PhotonArray.



                        [default: 0.]
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples when photon shooting. [default: True, unless <code>n_photons</code> is given, in which case the default is False] </td></tr>
    <tr><td class="paramname">sensor</td><td>An optional Sensor instance, which will be used to accumulate the photons onto the image. [default: None] </td></tr>
    <tr><td class="paramname">surface_ops</td><td>A list of operators that can modify the photon array that will be applied in order before accumulating the photons on the sensor. [default: ()] </td></tr>
    <tr><td class="paramname">maxN</td><td>Sets the maximum number of photons that will be added to the image at a time. (Memory requirements are proportional to this number.) [default: None, which means no limit] </td></tr>
    <tr><td class="paramname">orig_center</td><td>The position of the image center in the original image coordinates. [default: (0,0)] </td></tr>
    <tr><td class="paramname">local_wcs</td><td>The local wcs in the original image. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<p>Draws the k-space (complex) Image of the object, with bounds optionally set by input Image instance.</p>
<p>Normalization is always such that image(0,0) = flux. Unlike the real-space <a class="el" href="namespacegalsim_1_1gsobject.html#ae6973ff2ec617b3bce96aef8989afc41" title="Draw this profile into an Image by shooting photons. ">drawImage()</a> function, the (0,0) point will always be one of the actual pixel values. For even-sized images, it will be 1/2 pixel above and to the right of the true center of the image.</p>
<p>Another difference from <a class="el" href="namespacegalsim_1_1gsobject.html#ae6973ff2ec617b3bce96aef8989afc41" title="Draw this profile into an Image by shooting photons. ">drawImage()</a> is that a wcs other than a simple pixel scale is not allowed. There is no <code>wcs</code> parameter here, and if the images have a non-trivial wcs (and you don't override it with the <code>scale</code> parameter), a TypeError will be raised.</p>
<p>Also, there is no convolution by a pixel. This is just a direct image of the Fourier transform of the surface brightness profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the Image onto which to draw the k-space image. If <code>image</code> is None, then an automatically-sized image will be created. If <code>image</code> is given, but its bounds are undefined, then it will be resized appropriately based on the profile's size. [default: None] </td></tr>
    <tr><td class="paramname">nx</td><td>If provided and <code>image</code> is None, use to set the x-direction size of the image. Must be accompanied by <code>ny</code>. </td></tr>
    <tr><td class="paramname">ny</td><td>If provided and <code>image</code> is None, use to set the y-direction size of the image. Must be accompanied by <code>nx</code>. </td></tr>
    <tr><td class="paramname">bounds</td><td>If provided and <code>image</code> is None, use to set the bounds of the image. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale, dk, for the images. If <code>scale</code> is None and <code>image</code> is given, then take the provided images' pixel scale (which must be equal). If <code>scale</code> is None and <code>image</code> is None, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of <code>image</code>), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. Note: This requires that <code>image</code> be provided and that it has defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">recenter</td><td>Whether to recenter the image to put k = 0 at the center (True) or to trust the provided bounds (False). [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Image instance (created if necessary)</dd>
<dd>
(nphotons, photons) where nphotons is the total flux of photons that landed inside the image bounds, and photons is the <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions. ">PhotonArray</a> that was applied to the image. </dd></dl>

</div>
</div>
<a id="aaef2bb7bba98b07bd8b6db5421f2f7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef2bb7bba98b07bd8b6db5421f2f7f3">&#9670;&nbsp;</a></span>drawKImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawKImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ny</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recenter</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec9a5d6668a021b5497fb3ea190629da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9a5d6668a021b5497fb3ea190629da">&#9670;&nbsp;</a></span>drawPhot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawPhot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sensor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>surface_ops</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxN</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orig_center</em> = <code><a class="el" href="classgalsim_1_1position_1_1_position_i.html">PositionI</a>(0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>local_wcs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a397edd083aaa67c2d977684bdf39e212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397edd083aaa67c2d977684bdf39e212">&#9670;&nbsp;</a></span>drawReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.drawReal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bb518d71fbdf5233157bff8bb149b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb518d71fbdf5233157bff8bb149b6f">&#9670;&nbsp;</a></span>evaluateAtWavelength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.evaluateAtWavelength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a959ca0de3443c2505d5d39bbb913be78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ca0de3443c2505d5d39bbb913be78">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a572a08c6fe143b3cf4b68682265ef578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572a08c6fe143b3cf4b68682265ef578">&#9670;&nbsp;</a></span>getGoodImageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.getGoodImageSize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pixel_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c15cd01110eefc7928d06b154d50ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c15cd01110eefc7928d06b154d50ae0">&#9670;&nbsp;</a></span>gsparams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.gsparams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>
<p>The expectation value of flux in positive photons. </p><pre class="fragment">    Some profiles, when rendered with photon shooting, need to shoot both positive- and
    negative-flux photons.  For such profiles, this method returns the total flux
    of the positive-valued photons.
</pre><p> Returns the expectation value of flux in negative photons. </p><pre class="fragment">    Some profiles, when rendered with photon shooting, need to shoot both positive- and
    negative-flux photons.  For such profiles, this method returns the total absolute flux
    of the negative-valued photons (i.e. as a positive value).
</pre><p> An estimate of the maximum surface brightness of the object. </p><pre class="fragment">    Some profiles will return the exact peak SB, typically equal to the value of
    obj.xValue(obj.centroid).  However, not all profiles (e.g. Convolution) know how to
    calculate this value without just drawing the image and checking what the maximum value is.
    Clearly, this would be inefficient, so in these cases, some kind of estimate is returned,
    which will generally be conservative on the high side.
</pre><p> An estimate of the noise already in the profile. </p><pre class="fragment">    Some profiles have some noise already in their definition.  E.g. those that come from
    observations of galaxies in real data.  In GalSim, RealGalaxy objects are an example of
    this.  In these cases, the noise attribute gives an estimate of the Noise object that
</pre><p> Return profile at a given wavelength. For <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances, this is just <code>self</code>. This allows <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> instances to be duck-typed as ChromaticObject instances. would generate noise consistent with that already in the profile.</p>
<p>It is permissible to attach a noise estimate to an existing object with </p><pre class="fragment">&gt;&gt;&gt; obj.noise = noise    # Some BaseNoise instance
</pre><p> Scale the flux of the object by the given factor. </p><pre class="fragment">    obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)

    It creates a new object that has the same profile as the original, but with the
    surface brightness at every location scaled by the given amount.
</pre><p>Equivalent to obj * othe You can also multiply by an SED, which will create a ChromaticObject where the SED acts like a wavelength-dependent <code>flux_ratio</code>.</p>
<pre class="fragment">    This routine is mainly used by the photon shooting process, where an overestimate of
    the maximum surface brightness is acceptable.

    Note, for negative-flux profiles, this will return the absolute value of the most negative
</pre><p> Equivalent to obj * (1/other) surface brightness. Technically, it is an estimate of the maximum deviation from zero, rather than the maximum value. For most profiles, these are the same thing.</p>
<pre class="fragment">    For profiles that don't have this complication, this returns 0.

    It should be generally true that `obj.positive_flux - obj.negative_flux` returns the same
    thing as `obj.flux`.  Small difference may accrue from finite numerical accuracy in
    cases involving lookup tables, etc.


    For profiles that don't have this complication, this is equivalent to getFlux().

    It should be generally true that `obj.positive_flux - obj.negative_flux` returns the same
    thing as `obj.flux`.  Small difference may accrue from finite numerical accuracy in
</pre><p> Returns the half-light radius of the object. </p><pre class="fragment">    If the profile has a half_light_radius attribute, it will just return that, but in the
    general case, we draw the profile and estimate the half-light radius directly.

    This function (by default at least) is only accurate to a few percent, typically.
    Possibly worse depending on the profile being measured.  If you care about a high
    precision estimate of the half-light radius, the accuracy can be improved using the
    optional parameter scale to change the pixel scale used to draw the profile.

    The default scale is half the Nyquist scale, which were found to produce results accurate
    to a few percent on our internal tests.  Using a smaller scale will be more accurate at
    the expense of speed.

    In addition, you can optionally specify the size of the image to draw. The default size is
    None, which means drawImage will choose a size designed to contain around 99.5% of the
    flux.  This is overkill for this calculation, so choosing a smaller size than this may
    speed up this calculation somewhat.

    Also, while the name of this function refers to the half-light radius, in fact it can also
    calculate radii that enclose other fractions of the light, according to the parameter
    `flux_frac`.  E.g. for r90, you would set flux_frac=0.90.

    The default scale should usually be acceptable for things like testing that a galaxy
    has a reasonable resolution, but they should not be trusted for very fine grain
    discriminations.
</pre><p> Returns an estimate of the radius based on unweighted second moments. </p><pre class="fragment">    The second moments are defined as:

    Q_ij = int( I(x,y) i j dx dy ) / int( I(x,y) dx dy )
    where i,j may be either x or y.

    If I(x,y) is a Gaussian, then T = Tr(Q) = Qxx + Qyy = 2 sigma^2.  Thus, one reasonable
    choice for a "radius" for an arbitrary profile is sqrt(T/2).

    In addition, det(Q) = sigma^4.  So another choice for an arbitrary profile is det(Q)^1/4.

    This routine can return either of these measures according to the value of the `rtype`
    parameter.  `rtype='trace'` will cause it to return sqrt(T/2).  `rtype='det'` will cause
    it to return det(Q)^1/4.  And `rtype='both'` will return a tuple with both values.

    Note that for the special case of a Gaussian profile, no calculation is necessary, and
    the `sigma` attribute will be used in both cases.  In the limit as scale-&gt;0, this
    function will return the same value, but because finite pixels are drawn, the results
    will not be precisely equal for real use cases.  The approximation being made is that
    the integral of I(x,y) i j dx dy over each pixel can be approximated as
    int(I(x,y) dx dy) * i_center * j_center.

    This function (by default at least) is only accurate to a few percent, typically.
    Possibly worse depending on the profile being measured.  If you care about a high
</pre><p> Returns the full-width half-maximum (FWHM) of the object. </p><pre class="fragment">    If the profile has a fwhm attribute, it will just return that, but in the general case,
    we draw the profile and estimate the FWHM directly.

    As with calculateHLR and calculateMomentRadius, this function optionally takes size and
    scale values to use for the image drawing.  The default is to use the the Nyquist scale
    for the pixel scale and let drawImage choose a size for the stamp that will enclose at
    least 99.5% of the flux.  These were found to produce results accurate to well below
    one percent on our internal tests, so it is unlikely that you will want to adjust
    them for accuracy.  However, using a smaller size than default could help speed up
    the calculation, since the default is usually much larger than is needed.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid] <pre class="fragment">    @returns an estimate of the full-width half-maximum in physical units

    precision estimate of the radius, the accuracy can be improved using the optional
    parameters size and scale to change the size and pixel scale used to draw the profile.

    The default is to use the the Nyquist scale for the pixel scale and let drawImage
    choose a size for the stamp that will enclose at least 99.5% of the flux.  These
    were found to produce results accurate to a few percent on our internal tests.
    Using a smaller scale and larger size will be more accurate at the expense of speed.

    The default parameters should usually be acceptable for things like testing that a galaxy
    has a reasonable resolution, but they should not be trusted for very fine grain
    discriminations.  For a more accurate estimate, see galsim.hsm.FindAdaptiveMom.
</pre></td></tr>
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid] </td></tr>
    <tr><td class="paramname">rtype</td><td>There are three options for this parameter:<ul>
<li>'trace' means return sqrt(T/2)</li>
<li>'det' means return det(Q)^1/4</li>
<li>'both' means return both: (sqrt(T/2), det(Q)^1/4) [default: 'det']</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the value of the object at a chosen 2D position in real space. </p><pre class="fragment">    This function returns the surface brightness of the object at a particular position
    in real space.  The position argument may be provided as a PositionD or PositionI
    argument, or it may be given as x,y (either as a tuple or as two arguments).

    The object surface brightness profiles are typically defined in world coordinates, so
    the position here should be in world coordinates as well.

    Not all GSObject classes can use this method.  Classes like Convolution that require a
    Discrete Fourier Transform to determine the real space values will not do so for a single
    position.  Instead a GalSimError will be raised.  The xValue() method is available if and
    only if `obj.is_analytic_x == True`.

    Users who wish to use the xValue() method for an object that is the convolution of other
    profiles can do so by drawing the convolved profile into an image, using the image to
    initialize a new InterpolatedImage, and then using the xValue() method for that new object.
</pre><p>Equivalent to xValue(pos), but pos must be a galsim.PositionD instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position at which you want the surface brightness of the object. <pre class="fragment">    @returns the surface brightness at that position.
</pre></td></tr>
    <tr><td class="paramname">position</td><td>The position at which you want the surface brightness of the object. <pre class="fragment">    @returns the surface brightness at that position.

    @returns an estimate of the radius in physical units (or both estimates if rtype == 'both')
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Returns the value of the object at a chosen 2D position in k space. </p><pre class="fragment">    This function returns the amplitude of the fourier transform of the surface brightness
    profile at a given position in k space.  The position argument may be provided as a
    PositionD or PositionI argument, or it may be given as kx,ky (either as a tuple or as two
</pre><p> Equivalent to kValue(kpos), but kpos must be a galsim.PositionD instance. </p><pre class="fragment">    arguments).

    Technically, kValue() is available if and only if the given obj has `obj.is_analytic_k
    == True`, but this is the case for all GSObjects currently, so that should never be an
    issue (unlike for xValue()).
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in k space at which you want the fourier amplitude.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a version of the current object with the given gsparams </p><pre class="fragment">    Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
          those component objects will also have their gsparams updated to the new value.

    @returns the amplitude of the fourier transform at that position.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>If given, the stamp size to use for the drawn image. [default: None, which will let drawImage choose the size automatically] </td></tr>
    <tr><td class="paramname">scale</td><td>If given, the pixel scale to use for the drawn image. [default: 0.5 * self.nyquist_scale] </td></tr>
    <tr><td class="paramname">centroid</td><td>The position to use for the centroid. [default: self.centroid] </td></tr>
    <tr><td class="paramname">flux_frac</td><td>The fraction of light to be enclosed by the returned radius. [default: 0.5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the half-light radius in physical units</dd></dl>
<p>cases involving lookup tables, etc. </p>

</div>
</div>
<a id="ac80e3de821a725e619e18709bc803658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80e3de821a725e619e18709bc803658">&#9670;&nbsp;</a></span>has_hard_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.has_hard_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94227359893297c1c509ca1760d644a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94227359893297c1c509ca1760d644a3">&#9670;&nbsp;</a></span>interpolated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.interpolated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17b9aa8e3d2ccb9adfa56fce465c328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b9aa8e3d2ccb9adfa56fce465c328f">&#9670;&nbsp;</a></span>is_analytic_k()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.is_analytic_k </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e044f7f8ecbf4f015f1546b8a32fe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e044f7f8ecbf4f015f1546b8a32fe06">&#9670;&nbsp;</a></span>is_analytic_x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.is_analytic_x </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a120af2a83a0905c761ca73e1fa0f0129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120af2a83a0905c761ca73e1fa0f0129">&#9670;&nbsp;</a></span>is_axisymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.is_axisymmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2461ca769d1d0dc874ac0e710e2326d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2461ca769d1d0dc874ac0e710e2326d8">&#9670;&nbsp;</a></span>kValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.kValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2251c40af156536ec9bb424d6445c145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2251c40af156536ec9bb424d6445c145">&#9670;&nbsp;</a></span>lens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.lens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64c7425148437d0ca97bb1891e20cfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c7425148437d0ca97bb1891e20cfd7">&#9670;&nbsp;</a></span>magnify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.magnify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32148e7e635ad981809d044f50a8a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32148e7e635ad981809d044f50a8a92a">&#9670;&nbsp;</a></span>max_sb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.max_sb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e788d483fd183f1e56939f7243998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e788d483fd183f1e56939f7243998f">&#9670;&nbsp;</a></span>maxk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.maxk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1d700b162e2c74304ca487ab315a5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d700b162e2c74304ca487ab315a5e4">&#9670;&nbsp;</a></span>negative_flux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.negative_flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7f9f5b1fdf5ddffc75f1974fcd11e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f9f5b1fdf5ddffc75f1974fcd11e85">&#9670;&nbsp;</a></span>noise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.noise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b5d60a49f5202147791b29bbe1d73f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5d60a49f5202147791b29bbe1d73f2">&#9670;&nbsp;</a></span>noise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.noise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28ca2218650d47a86f7913af5480367d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ca2218650d47a86f7913af5480367d">&#9670;&nbsp;</a></span>nyquist_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.nyquist_scale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7cf0e1c414f8fff18800a747e329c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cf0e1c414f8fff18800a747e329c26">&#9670;&nbsp;</a></span>positive_flux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.positive_flux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d24b55ce76143422839ae65763d95dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d24b55ce76143422839ae65763d95dd">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.rotate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8460e71958b78a8bf0fff5564fe64803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8460e71958b78a8bf0fff5564fe64803">&#9670;&nbsp;</a></span>SED()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.SED </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a version of the current object with the flux scaled by the given <code>flux_ratio</code>. </p>
<p>This function is equivalent to <code>obj.withFlux(flux_ratio * obj.flux)</code>. Indeed, <a class="el" href="namespacegalsim_1_1gsobject.html#a794d75d32920b4903e8b238a6d65e06b">withFlux()</a> is implemented in terms of this one.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount. If <code>flux_ratio</code> is an SED, then the returned object is a <code>ChromaticObject</code> with an SED multiplied by obj.flux. Note that in this case the <code>.flux</code> attribute of the <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> being scaled gets interpreted as being dimensionless, instead of having its normal units of [photons/s/cm^2]. The photons/s/cm^2 units are (optionally) carried by the SED instead, or even left out entirely if the SED is dimensionless itself (see discussion in the ChromaticObject docstring). The <a class="el" href="classgalsim_1_1gsobject_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> <code>flux</code> attribute <em>does</em> still contribute to the ChromaticObject normalization, though. For example, the following are equivalent: </p><pre class="fragment">&gt;&gt;&gt; chrom_obj = gsobj.withScaledFlux(sed * 3.0)
&gt;&gt;&gt; chrom_obj2 = (gsobj * 3.0).withScaledFlux(sed)
</pre><p>An equivalent, and usually simpler, way to effect this scaling is </p><pre class="fragment">&gt;&gt;&gt; obj = obj * flux_ratio
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux_ratio</td><td>The ratio by which to rescale the flux of the object when creating a new one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux. </dd></dl>

</div>
</div>
<a id="a7f220be92202d1e095c2232b5ad750f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f220be92202d1e095c2232b5ad750f9">&#9670;&nbsp;</a></span>separable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.separable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cae2c77532c9be663fc55f59fb55c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cae2c77532c9be663fc55f59fb55c06">&#9670;&nbsp;</a></span>shear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a257acf514b2875ac6c0804503338dfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257acf514b2875ac6c0804503338dfa4">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb21bb4921aa8cca354157be9ed3bd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb21bb4921aa8cca354157be9ed3bd32">&#9670;&nbsp;</a></span>shoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.shoot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafff15b78fa86378f8a5102cc21fa7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafff15b78fa86378f8a5102cc21fa7ed">&#9670;&nbsp;</a></span>spectral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.spectral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e6e47cab50c665224aa7c6ca5e3e25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6e47cab50c665224aa7c6ca5e3e25d">&#9670;&nbsp;</a></span>stepk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.stepk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae83ddcb69020c3e8f9567dc23f7ad697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83ddcb69020c3e8f9567dc23f7ad697">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1a1c28bb2875092883922735da08f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a1c28bb2875092883922735da08f08">&#9670;&nbsp;</a></span>wave_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.wave_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a794d75d32920b4903e8b238a6d65e06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794d75d32920b4903e8b238a6d65e06b">&#9670;&nbsp;</a></span>withFlux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.withFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5300dc23b60baa5e7020491e9b40567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5300dc23b60baa5e7020491e9b40567">&#9670;&nbsp;</a></span>withGSParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.withGSParams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gsparams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa88f4babc5c4e58c53877c86d227712a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88f4babc5c4e58c53877c86d227712a">&#9670;&nbsp;</a></span>withScaledFlux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.withScaledFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59a5aae085d62f2fb25f099205474d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a5aae085d62f2fb25f099205474d57">&#9670;&nbsp;</a></span>xValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.gsobject.xValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a55cc27dc0194c107fa345f68d4612550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cc27dc0194c107fa345f68d4612550">&#9670;&nbsp;</a></span>flux</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.gsobject.flux</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14</small></address>
</body>
</html>
